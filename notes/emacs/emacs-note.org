#+TITLE: Emacs Note
#+filetags: emacs
#+hugo_base_dir: /home/awannaphasch2016/org/projects/sideprojects/website/my-website/hugo/quickstart

* Blogs :blog:
** Building fundamental in Emacs: How to customize key binding in vanilla Emacs?
:PROPERTIES:
:EXPORT_FILE_NAME: Building fundamental in Emacs: How to customize key binding in vanilla Emacs?
:ID:       fd1953d6-0d3a-458b-a7d5-2471960f885a
:END:

When I first get into Emacs, I was a vim user before, so I picked up Doom Emacs without experience with vanilla Emacs. Transition has been smooth so far, but because I never has experience with Vanilla Emacs before when I encounter a bug in Doom Emacs. I always have to first figure out if it is Doom Emacs problem or Emacs problems. Because of this, I put out a new blog series to help me build a stronger foundation of Vanilla Emacs.


I started of the series with a topic that irritate me quite often, key binding.

My goal of this blog is as followed
1. Understand priority of keymaps
2. Understand stand enough to distinguish vanilla Emacs problem from Doom problem.

This is a summarize of =Emacs Internal Manual under Emacs topic on chapter 49.3 Key Binding Chapter=.

*** Keymaps
Most modes have their own key binding which can overwrite your custom keybinding. For this reasons Emacs has reserve small number of keys to create a "safe space" for custom or build-in key binding example of these are 'C-c <a char>'', 'F5' - 'F9' keys.

Key sequence and its command function are recorded in Emacs as a data structure called "keymaps".

Keymap's value consist of =sequence of key binding= and =command= where =sequence of key binding= can either be a key or a =chain of keymaps=, more in "Visualize how a chain of keymaps works" section. In the other word, a keymap is a map between presentation of =key sequence= to a command.

Note that since =keymaps= is simply just a data structure. A mode can define its own =keymaps= such as =org-mode-map= etc.

To inspect current keymaps availble in a buffer, you can use =C-h b=.

Keymaps accepts values from variety of keys including '<Home>' and mouse.

*** Prefix
Emacs interprets one keymap at a time, however, a "chain" of keymap commands is also accepted. A "chain" of keymap  contains "prefix". "prefix" is a keymap that map to other keymaps.

Some keymap (not all) have symbols representation, for example, symbol of 'C-x' is 'Control-X-prefix'.

*** Local Keymaps
:PROPERTIES:
:ID:       2da596bf-c2f5-4e73-b364-cf79664d281f
:END:
local keymaps can have their own prefix key.

It is important to note that global prefix is ALWAYS vulnerable to be overwritten by higher priority keys. Still, there are keys that are reserved for the user. (From what I have read, it is unclear which keys are reserved.)

When local keymap is defined, global keymaps and local keymaps are chain together.
To clarify, given that we have "C-x C-z h", "C-x" is global prefix and "C-z" is local prefix. instead of one "C-x C-z" prefix.
*** Visualize how a chain of keymaps works?

This is how I think of it visually. It maybe incorrect or imprecise, but, at least, it helps me visualize in my head.

Says, we have a keymap =a,b,...,n= that map to =foo-command=.
Recall that a keymap is a map between presentation of =key sequence= to a command.
When sequence of key is pressed, a chain of keymap will be evaluated as followed.
#+BEGIN_SRC
(key a, keymap b)-> (key b, keymap c) -> ... -> (key n, foo-commands)
#+END_SRC

*** Key precedence (keymap lookup order)
:PROPERTIES:
:ID:       71b4d005-751c-47c7-aef6-268ab7fd98c4
:END:
local keymaps can be defined in 3 different places.
1. Major mode
2. Minor mode
3. area of text within a buffer.

To be more precise, in term of commands, key precedence (keymap lookup order) is as followed. Emacs look up keymap from top to bottom of the list.
1. ~overriding-terminal-local-map~ for terminal-specific key bind
2. ~overriding-local-map~
3. ~keymap char property at point~ keymaps for the current character. Yasnippet keymaps are in this category.
4. ~emulation-mode-map-alists~. Apparently, its more multi-mode keymap management. I am not sure what this means, but if i have to guess it is used in modes that have its known key precedence or other complexity that its key binding system brings. Evil mode keymap falls into this category.
5. ~minor-mode-overriding-map-alise~
6. ~minor-mode-map-alist~
7. ~keymap text property at point~
8. ~current-local-map~
9. ~current-global-map~

In [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html][Emacs Manual chapter 22.8 Searching the Active Keymaps]], pseudo-Lisp summary of how Emacs searches for active keymaps are mentioned which matched up with key precendence mentioned previously.
#+BEGIN_SRC emacs-lisp
(or (if overriding-terminal-local-map
        (find-in overriding-terminal-local-map))
    (if overriding-local-map
        (find-in overriding-local-map)
      (or (find-in (get-char-property (point) 'keymap))
          (find-in-any emulation-mode-map-alists)
          (find-in-any minor-mode-overriding-map-alist)
          (find-in-any minor-mode-map-alist)
          (if (get-text-property (point) 'local-map)
              (find-in (get-char-property (point) 'local-map))
            (find-in (current-local-map)))))
    (find-in (current-global-map)))
#+END_SRC

The search for keymap is finalized when a command is found. If a symbol is reached, emacs will replace the input key sequence with the symbol's value and restart the search.

**** Temporarily elevate keymap priority.
=transcient-map= is used to temporarily elevate a keymap to the highest precedence. This is done by calling =overriding-terminal-local-map=. (The highest keymap precedence)

*** Modifying Keybinding
Note that, Emacs always treats ‘C-A’ as ‘C-a’, ‘C-B’ as ‘C-b’, and so forth. This is because, in non-graphical environment,  'A' is the same as 'a.' To let Emacs know about the difference, we can pass in 'C-S-a' where S is <Shift>.

You have to think in the point of view of how computer compile information.

Emacs also accpets uncommon including <Super>, <Hyper>, and <Alt>, these are represented as 's-', 'H-', and 'A-'. Without these keys on the keyboard, you can still activate the key with 'C-x @ s', 'C-x @ h', and 'C-x @ a', respectively.

There are more valid keys. I only provide few examples.

The goal of modifying a keymap is to either modify =sequence of key binding= or =command= of a keymap.
**** Changing Keybinding for current Emacs session.
One can change keybinding for CURRENT Emacs session with the following options.
#+BEGIN_SRC
‘M-x global-set-key <RET> KEY CMD <RET>’
     Define KEY globally to run CMD.
‘M-x local-set-key <RET> KEY CMD <RET>’
     Define KEY locally (in the major mode now in effect) to run CMD.
‘M-x global-unset-key <RET> KEY’
     Make KEY undefined in the global map.
‘M-x local-unset-key <RET> KEY’
     Make KEY undefined locally (in the major mode now in effect).
#+END_SRC
**** Changing Keybinding permanently.
One can change keybinding permanently using the following commands.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c y") 'clipboard-yank)
(global-set-key (kbd "C-M-q") 'query-replace)
(global-set-key (kbd "<f5>") 'flyspell-mode)
(global-set-key (kbd "C-<f5>") 'display-line-numbers-mode)
(global-set-key (kbd "C-<right>") 'forward-sentence)
(global-set-key (kbd "<mouse-2>") 'mouse-save-then-kill)
#+END_SRC

One can also delay local keymap to be evaluated by using hook as followed.
#+BEGIN_SRC emacs-lisp
(add-hook 'texinfo-mode-hook
    (lambda ()
        (define-key texinfo-mode-map "\C-cp"
                    'backward-paragraph)
        (define-key texinfo-mode-map "\C-cn"
                    'forward-paragraph)))
        (define-key texinfo-mode-map "\C-c\C-xx" nil)
#+END_SRC

**** Rebinding with Mouse event
:PROPERTIES:
:ID:       30c68903-9c18-43ea-b937-a9ea08665758
:END:
valid key includes
#+BEGIN_SRC
[mouse-N] where 1 is the leftmost mouse button.
[drag-mouse-N]
[down-mouse-N]
[double-mouse-N]
#+END_SRC

keyboard prefix precedes mouse prefix.

Keybinding for clicking on frame has the following format [frame-type mouse-N]
frame-type includes
#+BEGIN_SRC
‘mode-line’
     The mouse was in the mode line of a window.
‘vertical-line’
     The mouse was in the vertical line separating side-by-side windows.
     (If you use scroll bars, they appear in place of these vertical
     lines.)
‘vertical-scroll-bar’
     The mouse was in a vertical scroll bar.  (This is the only kind of
     scroll bar Emacs currently supports.)
‘menu-bar’
     The mouse was in the menu bar.
‘tab-bar’
     The mouse was in a tab bar.
‘tab-line’
     The mouse was in a tab line.
‘header-line’
     The mouse was in a header line.
#+END_SRC
**** Disabling Commands
disable Commands silently
#+BEGIN_SRC emacs-lisp
(put 'delete-region 'disabled
    "It's better to use `kill-region' instead.\n")
#+END_SRC
disable commands with message
#+BEGIN_SRC emacs-lisp
(put 'delete-region 'disabled
    "It's better to use `kill-region' instead.\n")
#+END_SRC
**** How to load custom key binding, so it is not overwritten by other keymaps?
You might imagine to simply have one of these modifier keymap function in your init.el and keymaps will be rebind.

Not so fast.

Sometimes, major mode or minor mode may define their keybinding using mode-hook. In this case, keymaps that are defined later can override your init.el configuration. In the cases as this, you have to dig into thier souce code to understand when you want your new keybinding to be evaluated.

*** Conclusion
This blog summarizes =Emacs Internal Manual under Emacs topic on chapter 49.3 Key Binding Chapter=. We have learn that keymap priority based on context from highest to lowest: region in buffer, minor mode, and major mode.

Lastly, I have learned that vanilla Emacs doesn't exc. I can't say what exactly.
** A Note on X where X = "Byte Compile File In (Doom) Emacs"
Emacs will use =.elc= whenever its availble otherwise it will fall back to =.el=.

Sometimes, when you open Emacs, you see that source code is byte compiled. The byte compiler is an elisp based compiler that will take elisp, parse it, expand out macros and optimise code, it allows for some noticeable speed gains but also can lead to some debugging hell,

To see actual source code, one can remove =.elc= file of the file you want to inspect, see below. Reopen emacs and you should see non-compile source code.
#+BEGIN_SRC
rm -rf EMACSDIR/.local/straight/**/*.elc
#+END_SRC

Removing =.elc= implies that you are expected decrease in efficiency. However, I think performance drop should not be noticeable. You can always recompile the file.

Doom will not regenerate the byte compile files until you tell it too by calling doom build.
* Reference
** [[https://github.com/caiorss/Emacs-Elisp-Programming/blob/master/Elisp_Programming.org][emacs lisp tutorial in markdown]]
* Map of Contents (MOCs)
:PROPERTIES:
:ID:       f12c0c70-1af9-487f-84cb-ea1a4a8cf29b
:END:
** ~+eval/region~ and ~+eval/buffer~ doesn't send results from overlays to ~Message~ buffer, but ~eros-eval-last-sexp~ does.
*** Background (information and description of goal)
- note
  - Why are you doing this? What is the movitation?
  - What is your expectation of the results?

From my brief investigation, I notice that although all commands evaluate lisp code, it wasn't implemented on the same commands. (not much similarity beyond eval and overlays)
** How to Use File and Directory Local Variables
This MOCs is inspired by [fn:2]
*** file local variables
* Terms and Concepts
** struct
example of struct
#+BEGIN_SRC emacs-lisp
;; define struct
(cl-defstruct person name age sex)

;; how struct can be used
(setq dave (make-person :name "Dave" :sex 'male))
(setq other (copy-person dave))
(eq dave other)
(eq (person-name dave) (person-name other))
(person-p dave)
(person-p [1 2 3 4])
(person-p "Bogus")
(person-p '[cl-struct-person counterfeit person object])
#+END_SRC
** garbage collector | garbage collection
** syntax
*** what is #?
read [[https://stackoverflow.com/questions/4873810/what-does-mean-in-lisp][here]].
example
#+BEGIN_SRC emacs-lisp
(let ((foo 42))
  (flet ((foo () 'bar))
    (list foo (function foo) #'foo (foo))))
#+END_SRC

#+RESULTS:
| 42 | foo | foo | bar |

** Lexical binding vs dynamic binding
:PROPERTIES:
:ID:       e15c4443-c2a2-4fff-b9f1-b83ac25de8d6
:END:
- ref
  - [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][dynamic binding vs lexical binding]]
lexical binding (static binding) and dynamic binding refer to how variables are looked up by their names.

The main different between lexical bound and dynamic bound is that with dynamic bound all value that has been binding since the program started always exists while program is being executed.
#+BEGIN_SRC emacs-lisp
(let ((a 1))                            ; binding (1)
    (let ((f (lambda () (print a))))
    (let ((a 2))                        ; binding (2)
        (funcall f))))
#+END_SRC
=lexical bound= looks up binding in the lexical environemnt while =dynamic bound= looks up binding in the dynamic environment.

In the other word, in dynamic environment, all of the bindings since the started of the program are not destroyed as long as program is still running. In constrast to lexical environment, bindings are only defined within the scope that it is first defined.

A name that is lexically bound is looked up only in bindings in the lexical environment of the name  that is, in bindings that enclose the name in the source code. So if “a” is lexically bound, the code above prints “1”, because only binding (1) is in the lexical environment. When there are multiple bindings in the lexical environment, the innermost one is used.

A name that is dynamically bound is looked up only in bindings in the dynamic environment of the name  that is, in all bindings which have been created since the program began and which have not yet been destroyed. When there are multiple bindings in the dynamic environment, the most recently created one is used. So if “a” is dynamically bound, the code above prints “2” because both binding (1) and binding (2) have been created by the time “a” is evaluated, but binding (2) was created more recently.
** defcustom

** local variables

move variable between file and dir level
| commands                                 | key | doom keys | custom keys | descriptions |
| copy-dir-locals-to-file-locals           |     |           |             |              |
| copy-file-locals-to-dir-locals           |     |           |             |              |
| copy-dir-locals-to-file-locals-prop-line |     |           |             |              |

*** file local variable
| commands                   | key | doom keys | custom keys | descriptions                                      |
| add-file-local-variable    |     |           |             |                                                   |
| delete-file-local-variable |     |           |             |                                                   |
| enable-local-variables     |     |           |             | control use of local variables in files you visit |
| safe-local-eval-forms      |     |           |             | safe eval forms                                   |
| safe-local-variable-values |     |           |             | safe variable-value pairs (saved to custom-file)  |

*** directory local variable
| commands               | key | doom keys | custom keys | descriptions |
| add-dir-local-variable |     |           |             |              |
|                        |     |           |             |              |
**** .dir-locals
* Help sections and related info
** looking up documentation, see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#looking-up-documentation-3][here]].
:PROPERTIES:
:ID:       9e2582e8-3bb4-4f20-9a9a-535b42bcbec9
:END:

| commands                     | key     | doom keys | custom keys | descriptions          |
| helpful-function -> add-hook |         |           |             |                       |
| helpful-variable             |         | spc-h-v   |             |                       |
| helpful-key                  |         | spc-h-k   |             |                       |
| doom/help-custom-variable    |         | spc-h-V   |             |                       |
|                              | C-h C-h |           |             | show all describe-xxx |

seaching doom specific documentation

| commands                 | key | doom keys | custom keys | descriptions |
| doom/help-search         |     | spc-h-d-S |             |              |
| doom/help-search-heading |     | spc-h-d-s |             |              |

* Notes for Users (How to use things?)
** General key binding
:PROPERTIES:
:ID:       6235a579-abfd-4f76-9e5b-82983a1c8d9d
:END:
| commands               | key             | doom keys | custom keys | descriptions               |
| repeat                 | C-x z           |           |             | repeat last emacs commands |
| repeat-complex-command | C-x <Esc> <Esc> |           |             |                            |
** Built-in Packages and modes
:PROPERTIES:
:ID:       8a81f3e7-ccf4-4f05-b419-61c7dfcc55cc
:END:
*** Packages
**** Imenu
*****  How does Imenu function works?
:PROPERTIES:
:ID:       9dcaf4a1-4cd1-456a-b8e6-4ecb6c23bc6a
:END:
~imenu~ function when called when called will jump to a place in the buffer chosen using either a buffer menu or mouse menu.

#+BEGIN_SRC emacs-lisp
(imenu INDEX-ITEM)
#+END_SRC
Jump to a place in the buffer chosen using a buffer menu or mouse menu.
~INDEX-ITEM~ specifies the position.

#+BEGIN_SRC emacs-lisp
(imenu-choose-buffer-index &optional PROMPT ALIST)
#+END_SRC
~imenu-choose-buffer-index~ lets the user select from a buffer index and return the chosen index.

The returned value is of the form (INDEX-NAME . INDEX-POSITION) which is a format of simple elements in ~imenu--index-alist~.

~imenu--index-alist~ is the current buffer index alist.
~imenu--index-alist~ has the following elements:
- simple element
  (INDEX-NAME . POSITION)
- special elements
  (INDEX-NAME POSITION FUNCTION ARGUMENTS...).
- nested sub-alist element
  (INDEX-NAME . SUB-ALIST)

#+BEGIN_SRC emacs-lisp
(imenu-choose-buffer-index)
#+END_SRC

#+RESULTS:
: (Imenu . #<marker at 506 in emacs-note.org>)

#+BEGIN_SRC emacs-lisp
(imenu '((Imenu . #<marker at 506 in emacs-note.org>)))
#+END_SRC

****** [2021-11-07 Sun]: WHAT HAVE I DONE AND WHAT TO DO NEXT?
so the goal is to implement a simple imenu to reproduce the results of different call ~imenu~ on the buffer.

note: behavior of calling ~imenu~ using key binding is different from select ~imenu~ from ~M-x~. Given what I know, I speculate that ~imenu~ take input directly from buffer in which it is, hence, selecting ~imenu~ from ~M-x~ produce undesired side effects.

So far, I unable to pass output from ~imenu-choose-buffer-index~ (which, according to the documentation, suppose to produce INDEX-ITEM ) to ~imenu~, so I suspect that my understanding of ~marker~ concept may blind me from the error.

Next next I planned to read about ~marker~ from [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Markers.html][this page]].
**** Semantics Packages
***** References
- emacs documentations
***** Structure of Sematics packages
The following diagram illustrates the strucuture of the =Semantic= package

#+BEGIN_SRC md
                                                             Applications
                                                                 and
                                                              Utilities
                                                                -------
                                                               /       \
               +---------------+    +--------+    +--------+
         C --->| C      PARSER |--->|        |    |        |
               +---------------+    |        |    |        |
               +---------------+    | COMMON |    | COMMON |<--- SPEEDBAR
      Java --->| JAVA   PARSER |--->| PARSE  |    |        |
               +---------------+    | TREE   |    | PARSE  |<--- SEMANTICDB
               +---------------+    | FORMAT |    | API    |
    Scheme --->| SCHEME PARSER |--->|        |    |        |<--- ecb
               +---------------+    |        |    |        |
               +---------------+    |        |    |        |
   Texinfo --->| TEXI.  PARSER |--->|        |    |        |
               +---------------+    |        |    |        |

                    ...                ...           ...         ...

               +---------------+    |        |    |        |
   Lang. Y --->| Y      Parser |--->|        |    |        |<--- app. ?
               +---------------+    |        |    |        |
               +---------------+    |        |    |        |<--- app. ?
   Lang. Z --->| Z      Parser |--->|        |    |        |
               +---------------+    +--------+    +--------+
#+END_SRC

***** Semantic API
Semantic API is provided in all of the major steps in [[*\[\[https://www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-Components.html\]\[Components of Semantics\]\]][Components of Semantics]], best to read it from the documentation, see [[https://www.gnu.org/software/emacs/manual/html_node/semantic/index.html#SEC_Contents][here]].

***** Fundamentals
****** What is usecase of semantic?
Semantic provides a uniform, language-independent API for accessing the parser output. This output can be used by other Emacs Lisp programs to implement “syntax-aware” behavior. Semantic itself includes several such utilities, including user-level Emacs commands for navigating, searching, and completing source code.
******* Application/Modes that build on Semantic API
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Analyzer.html][Analyzer]]
The Semantic Analyzer is a library for performing context analysis on source code. It provides user commands for displaying, completing, and navigating through source code.
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Speedbar.html][Speedbar]]
Speedbar is a program for Emacs which can be used to summarize information related to the current buffer
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/SymRef.html][Symbol Reference (SymRef)]]
Semantic can interface with external symbol reference tools, such as GNU Global and GNU Idutils. These tools provide information about where different tags or symbols appear.
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/MRU-Bookmarks.html][Most Recently Used Bookmarks Mode (MRU Bookmarks Mode)]]
Semantic MRU Bookmarks mode is a minor mode that keeps track of the tags you have edited, allowing you to quickly return to them later (MRU stands for “Most Recently Used”).
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Sticky-Func-Mode.html][Sticky Function Mode]]
Semantic Sticky Function minor mode displays a header line that shows the declaration line of the function or tag on the topmost line in the text area. This allows you to keep that declaration line in view at all times, even if it is scrolls off the “top” of the screen.

In addition, clicking mouse-1 on the header line opens a context menu that contains menu items for copying, killing, or narrowing to that tag.

| commands | key | doom keys | custom keys | descriptions |
| commands                        | key | doom keys | custom keys | descriptions                                                         |
| global-semantic-stickyfunc-mode |     |           |             | Toggle Semantic Sticky Function mode in all Semantic-enabled buffers |

| Variables                          | Description                                                                                            |
| semantic-stickyfunc-sticky-classes | The value of this variable is a list of tag classes that Semantic Sticky Function mode makes “sticky”. |
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Highlight-Func-Mode.html][Highlight Function Mode]]
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Tag-Decoration-Mode.html][Tag Decoration Mode]]

****** Why is Semantic invented?
Ordinarily, Emacs uses regular expressions (and syntax tables) to analyze source code for purposes such as syntax highlighting. This approach, though simple and efficient, has its limitations: roughly speaking, it only “guesses” the meaning of each piece of source code in the context of the programming language, instead of rigorously “understanding” it.

****** How does semantic work?
Semantic provides a new infrastructure to analyze source code using parsers instead of regular expressions. It contains two built-in parser generators (an LL generator named Bovine and an LALR generator named Wisent, both written in Emacs Lisp), and parsers for several common programming languages. It can also make use of external parsersprograms such as GNU Global and GNU IDUtils.
****** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-Components.html][Components of Semantics]]
******* token stream and parser.
step by step of how paring a source code with Semantic works
1. lexical analysis
   1. break it up into its fundamental components
   #+BEGIN_SRC md
        syntax table, keywords list, and options
                         |
                         |
                         v
    input file  ---->  Lexer   ----> token stream
   #+END_SRC
   The output of the lexical analyzer is a list of tokens that make up the file.

   2. The next step is the actual parsing, shown below:
#+BEGIN_SRC md

                    parser tables
                         |
                         v
    token stream --->  Parser  ----> parse tree
#+END_SRC
******* SemanticDB
Cache results of parsing source code files using Semantic Database (SemanticDB)

Parsing large files can take several seconds or more. By default, Semantic automatically caches parse trees by saving them in your .emacs.d directory. When you revisit a previously-parsed file, the parse tree is automatically reloaded from this cache, to save time. See [[https://www.gnu.org/software/emacs/manual/html_node/semantic/SemanticDB.html][SemanticDB]].

By default, SemanticDB is enabled together with Semantic mode. To disable it, remove it from semantic-default-submodes (see [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html][Semantic mode]]). You can also enable or disable SemanticDB with M-x global-semanticdb-minor-mode.
**** Xref
- ref
  - [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html][28.4 Find Identifier References]]
Xref is used to display defintion of symbols and their references.

A mode's backend can use Xref in many ways. For example,
1. Some majors modes may search through loaded packages or by searching through documentation string. Disadvantage of this approach is that Xref can only find symbols that has been loaded.
2. Another approach is to scan throught relevant files and build database of symbols references. etags is one of the built-in example. Disadvantage of this approach is the reference tables need to be kept upto date.
*** Modes
**** edebug mode
- ref
  - tutorial
    - [[https://youtu.be/QRBcm6jFJ3Q?t=416][2015-04-08 Emacs Lisp Development Tips with John Wiegley]]
    - [[https://www.youtube.com/watch?v=odkYXXYOxpo&ab_channel=NicFerrier][Debugging basics]] (This one is more structured and easier to follow)

traditional ways of debugging is to =debug= function, see example below
#+BEGIN_SRC emacs-lisp
(defun foo ()
  (if t
      (progn
        (debug)
        (message "Hello, world"))
    (message "unimplemented")))

(foo)
#+END_SRC

set =toggle-debug-on-error= to t to enable debug on error.

Once in the edebug mode
| commands                   | key | doom keys | custom keys | descriptions |
| debugger-eval-expression   | e   |           |             |              |
| debugger-jump              |     |           |             |              |
| debugger-quit              |     |           |             |              |
| debugger-frame             |     |           |             |              |
| debugger-continue          |     |           |             |              |
| debugger-frame-clear       |     |           |             |              |
| debugger-return-value      |     |           |             |              |
| debugger-step-through      |     |           |             |              |
| debugger-list-functions    |     |           |             |              |
| debugger-eval-expression   |     |           |             |              |
| debugger-record-expression |     |           |             |              |
**** calendar mode
#+BEGIN_SRC emacs-lisp
;; (defun anak/insdate-insert-current-date
;;     )
#+END_SRC
**** info mode (I often recalled it incorrectly as help mode)
On the resting page, navigation with info mode is mentioned.
#+BEGIN_QUOTE
This (the Directory node) gives a menu of major topics.
Typing "q" exits, "H" lists all Info commands, "d" returns here,
"h" gives a primer for first-timers,
"mEmacs<Return>" visits the Emacs manual, etc.

In Emacs, you can click mouse button 2 on a menu item or cross reference
to select it.
#+END_QUOTE
***** Key binding
| commands       | key | doom keys | custom keys | descriptions                           |
| info-directory |     |           |             | go to the resting page of emacs manual |

** Built-in functionality and macros
*** Functionality
**** [[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][Ediff]]
ref:
[[https://www.youtube.com/watch?v=oXsaRENHlXY&ab_channel=oxyscbw][Exploring Emacs: Use/Set up ediff for comparing files for windows]]

Note: It is not intuitive to use at all. Unless, I need to use it, I am better without it.

| commands            | key | doom keys | custom keys | descriptions                    |
| ediff               |     |           |             |                                 |
| ediff3              |     |           |             |                                 |
| ediff-buffer        |     |           |             | compare buffers                 |
| ediff-revision      |     |           |             | 2 git brancehs 1 file           |
| vc-ediff            |     |           |             | look at vc changes from file    |
| ediff-current-file  |     |           |             | unsaved changes (revert-buffer) |
| ediff-documentation |     |           |             | documentation for ediff         |

**** Align
| commands    | key | doom keys | custom keys | descriptions |
| align-regex |     |           |             |              |
**** Things related to clocking and time
| commands                | key | doom keys | custom keys | descriptions                                            |
| calendar-sunrise-sunset |     |           |             | Local time of sunrise and sunset for date under cursor. |
**** Search and Replace functionality
| commands      | key | doom keys | custom keys | descriptions |
| query-replace |     | M-s-%     |             |              |
*** Emacs components
**** Buffer
***** How =display-buffer= works
- ref
  - [[https://www.youtube.com/watch?v=-H2nU0rsUMY&ab_channel=SystemCrafters][Hey Emacs, Don't Move My Windows! - Customizing display-buffer's behavior]]

When a new buffer is created for display, Emacs uses the =display-buffer= function to figure out where this buffer should be placed on screen.

=display-buffer= consults a series of sources =in order= which contain rules for how windows are selected (or created) to display new buffers:

    1. =display-buffer-overriding-action= - Used by package code to
    temporarily override rules
    2. =display-buffer-alist= - User-defined buffer placement rules (nil by default)
    3. The =action= argument of =display-buffer= - The caller of =display-buffer= can specify its own rules
        #+BEGIN_SRC emacs-lisp
        (display-buffer BUFFER-OR-NAME &optional ACTION FRAME)
        #+END_SRC
    4. =display-buffer-base-action= - User-defined default placememt actions (nil by default)
    5. =display-buffer-fallback-action= - Emacs' default placement rule you see in action every day which the buffer can be displayed. The action function's window (or frame!) in which the buffer will be displayed* Buffers

=display-buffer= builds a list of action functions to try by combining all of these sources and then runs each function in order until one of them returns a window in which the buffer can be displayed. The action function's job is to find (or create) the window (or frame!) in which the buffer will be displayed.

#+BEGIN_SRC emacs-lisp
(display-buffer (get-buffer-create "*doom:scratch*"))
#+END_SRC

#+RESULTS:
: #<window 21 on Test!>

***** What is an action functions?
=signature= of an action function:
#+BEGIN_SRC emacs-lisp
(display-buffer-same-window BUFFER ALIST)
#+END_SRC

=display-buffer= will pass the buffer to be displayed and an association list that the action function can read to look for customizaiton parameters.

**** Marker
*** Completion mechanism
oen of the most important features of the user interface is the way in which the user makes selections from lists of items. for example:

- Opening files
- Switching buffers
- Using M-x to execute commands

There exist package which provide different ways of displaying selections e.g. =ido=, =icomplete=, etc.

More popular adoption is to use =completion framework= like =Helm= or =Ivy= which provide enhanced interfaces and special commands that provide additional behavior.

On the other hand, =Selectr=um and =Vertico= provide you with just completion functionality to build your own =completion framework=.
*** Regex
**** =re-builder= construct a regexp interactively on target buffer, see [[https://www.masteringemacs.org/article/re-builder-interactive-regexp-builder][here]].
** Things that effects how emacs behave
*** Process
**** Proper way to call a process
Use the =call-process= function and direct it to a buffer
** Major modes
Order in which emacs looks for major mode.
ref: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html][Choosing File Modes]]
1. file-local variables
   #+BEGIN_SRC md
    ; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-
   #+END_SRC

2. Second, if there is no file variable specifying a major mode, Emacs checks whether the file’s contents begin with ‘#!’.

3. Third, Emacs tries to determine the major mode by looking at the text at the start of the buffer, based on the variable ~magic-mode-alist~.

4. Fourthif Emacs still hasn’t found a suitable major modeit looks at the file’s name. The correspondence between file names and major modes is controlled by the variable ~auto-mode-alist~

5. Finally, if Emacs still hasn’t found a major mode to use, it compares the text at the start of the buffer to the variable ~magic-fallback-mode-alist~
*** term mode
- ref
  - https://www.gnu.org/software/emacs/manual/html_node/elisp/Multiple-Terminals.html
**** Emacs represents each terminal as a terminal object data type (see Terminal Type).
**** Each terminal object has the following attributes:
***** The name of the device used by the terminal (e.g., ‘:0.0’ or /dev/tty).
***** The terminal and keyboard coding systems used on the terminal. See Terminal I/O Encoding.
***** The kind of display associated with the terminal. This is the symbol returned by the function terminal-live-p (i.e., x, t, w32, ns, or pc). See Frames.
***** A list of terminal parameters. See Terminal Parameters.
*** shell mode
** Minor modes
*** term-char-mode and term-line-mode.
**** an ordinary terminal mode operate in the equivalent of character mode.
**** In line mode, Term basically acts like Shell mode (see Shell Mode). In char mode, each character is sent directly to the subshell, except for the Term escape character, normally C-c.
**** Why might you want to use one over the other? Line mode allows you to perform Emacs editing operations on what you write, to accumulate multiple lines to send through at once, and to perform tab completion of filenames in Emacs. See the list of commands in shell mode for details. Character mode lets you use all the features of the underlying process, like its own (likely better) tab completion, rather than the Emacs operations, and also to send through inputs that Emacs would have interpreted as referring to its own commands (like Ctrl-X). This is also the mode you'd want if you wanted to run vim inside emacs.
**** term-line-mode
***** When run (term-line-mode), wwitch to line ("cooked") sub-mode of term mode. This means that Emacs editing commands work as normally, until you type M-x term-send-input which sends the current line to the inferior.
**** term-char-mode
***** Switch to char ("raw") sub-mode of term mode. Each character you type is sent directly to the inferior without intervention from Emacs, except for the escape character (usually C-c).
** Navigation
*** org-mode and table

| Commands           | Keys  | description                                                    |
| org-metaleft       | M-h   | Promote heading, list item at point or move table column left. |
| org-metaright      | M-l   | Demote heading, list item at point or move table column right. |
| org-metaup         | M-k   | Move subtree up or move table row up.                          |
| org-metadown       | M-j   | Move subtree down or move table row down.                      |
| org-shiftmetaleft  | M-S-h | Promote subtree or delete table column.                        |
| org-shiftmetaright | M-S-l | Demote subtree or insert table column.                         |
| org-shiftmetaup    | M-S-k | Drag the line at point up                                      |
| org-shiftmetadown  | M-S-j | default-indent-new-line                                        |

*** Windows
**** Key-binding
:PROPERTIES:
:ID:       bd1a31c8-a47a-43aa-8a9a-3609a8e481e5
:END:
I figure its best to only list the one I use often.

Note: =prior= key is =pageup=

| command                             | native key | doom key  | custom key | description                |
| delete-window                       | C-x 0      |           | spc-w-0    |                            |
| delete-other-windows                | C-x 1      |           | spc-w-1    |                            |
| evil-window-vsplit                  |            | spc-w-v   |            |                            |
| +evil/window-vsplit-and-follow      |            | spc-w-V   |            |                            |
| shrink-window                       | NA         | NA        |            | shrink vertically          |
| shrink-window-horizontally          | C-x {      |           |            |                            |
| shrink-window-if-larger-than-buffer | C-x -      |           |            |                            |
| enlarge-window                      | C-x ^      |           |            | enlarge vertically         |
| enlarge-window horizontally         | C-x }      |           |            |                            |
| balance-windows                     |            | spc-w-=   |            |                            |
| doom-window-enlarger                |            | spc-w-o   |            |                            |
| window-tear-off                     |            | spc-w-T   |            |                            |
| winner-redo                         |            | spc-w-C-r | spc-w-r    | redo all windows positions |
| winner-undo                         |            | spc-w-C-u | spc-w-u    | undo all windows positions |
| +evil/window-move-up                |            | spc-w-K   |            |                            |
| +evil/window-move-left              |            | spc-w-L   |            |                            |
| +evil/window-move-down              |            | spc-w-J   |            |                            |
| +evil/window-move-right             |            | spc-w-R   |            |                            |
| ace-window                          |            | spc-w-a   |            | jump to window by number   |
| scroll-other-window                 | C-M-S-v    |           |            |                            |
| scroll-other-window-down            | C-M-v      |           |            |                            |
| find-file-other-window              |            |           | spc-w-f    | other file in other window |
** Things related to managing and loading packages
*** =init.el= vs =config.el= vs use-package's =preface= flags [fn:1]
**** =init.el= vs =config.el=
=init.el= is loaded before =require=
=config.el= is loaded after =require=

**** =init.el= vs use-package's =preface= flag

tldr:
=init.el= doesn't raise warning if some code fails to load.
use-package's =preface= flag raise warming if it fails to load.

detail:
=init.el= is intended to be used for things that you don't always need.
#+BEGIN_QUOTE
things in =inite.el= are good to have, but emacs should still work without it.
#+END_QUOTE
Hence, error in =init.el= will not raise backtrace. (it just skip things that don't work. The rest of the code in init.el will still be processed.)
To let use aware that some code are skipped in =init.el=, warning is raised.

When it fails to load things that should have been prepared during =init.el=, no further warning is raised. (beacuse it already raised.) only message that it couldn't be loaded will be shown.

Similar to =init.el=, use-package's =preface= flag are availble during compilation time. Even before =init.el= but it is expected to not fail, so warning will be raised if it failed to load . (since it is used with =use-package= which is used during =config.el=)
** Useful functionality and packages to improve your workflow
*** =shell-command=
=shell-command= (=M-x !=)
=shell-command-on-region= (=M-x |=)
**** learn by example
#+BEGIN_SRC emacs-lisp :noeval
;; ref: https://www.masteringemacs.org/article/executing-shell-commands-emacs#:~:text=The%20Basics,*Shell%20Command%20Output*%20buffer.
(defun tidy-html ()
  "Tidies the HTML content in the buffer using `tidy'"
  (interactive)
  (shell-command-on-region
   ;; beginning and end of buffer
   (point-min)
   (point-max)
   ;; command and parameters
   "tidy -i -w 120 -q"
   ;; output buffer
   (current-buffer)
   ;; replace?
   t
   ;; name of the error buffer
   "*Tidy Error Buffer*"
   ;; show error buffer?
   nil))
#+END_SRC

*** =macrosteop=
    Expand the macro form following point by one step.

*** Conditions related function
**** =-andfn= return
Return a predicate that returns non-nil if all PREDS do so.

#+BEGIN_SRC emacs-lisp
(funcall (-andfn #'numberp #'cl-evenp) 4)
#+END_SRC
*** Folding
[[https://stackoverflow.com/questions/27617090/the-scope-of-python-code-folding-in-emacs][The scope of python code folding in emacs]]

* Notes for Developers (How to do and fix things)
** Useful funcstions and customized function
*** Match Data
- ref
  - https://www.gnu.org/software/emacs/manual/html_node/elisp/Simple-Match-Data.html
**** match string of input
#+BEGIN_SRC emacs-lisp
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789
     ⇒ 4

(match-string 0 "The quick fox jumped quickly.")
     ⇒ "quick"
(match-string 1 "The quick fox jumped quickly.")
     ⇒ "qu"
(match-string 2 "The quick fox jumped quickly.")
     ⇒ "ick"

(match-beginning 1)       ; The beginning of the match
     ⇒ 4                 ;   with ‘qu’ is at index 4.

(match-beginning 2)       ; The beginning of the match
     ⇒ 6                 ;   with ‘ick’ is at index 6.

(match-end 1)             ; The end of the match
     ⇒ 6                 ;   with ‘qu’ is at index 6.

(match-end 2)             ; The end of the match
     ⇒ 9                 ;   with ‘ick’ is at index 9.
#+END_SRC

**** match string in a buffer
***** re-search-forward match string in buffer and move point to the match
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
  (insert "# Intro\n"
          "# Usage\n"
          "# License\n")
  (goto-char (point-min))
  (let ((matches '()))
    (while (re-search-forward "^# \\(.+\\)$" nil t)
      (push (match-string 1) matches))
    (nreverse matches)))
#+END_SRC


** Customization
*** set keys binding
mapping new key binding to non-defined prefix (by emacs).
#+BEGIN_SRC elisp
(global-set-key (kbd "C-x !") 'enlarge-window-maximize)
#+END_SRC

#+RESULTS:

mapping new key binding to existing prefix (defined by doom emacs)
#+BEGIN_SRC emacs-lisp
(map! :leader "d d" #'dap-debug)
#+END_SRC
*** Customize Your IDE environment
- ref
  - [[http://tuhdo.github.io/index.html][Emacs mini manual series]] (Lots of stuff related to functionality that relevant to IDE experience.)
    - [[http://tuhdo.github.io/c-ide.html#sec-9-2][C/C++ Development Environment for Emacs]] (General info on how to customize your own IDE goes beyond C/C++)
** Evaluating elisp
- ref
  - [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#evaluating-elisp-on-the-fly-6][Evaluating elisp on the fly]]

| commands                     | key | doom keys | custom keys | descriptions |
| +eval:region                 |     | g r       |             |              |
| +eval/buffer                 |     | g R       |             |              |
| +eval/buffer-or-region       |     | C-c e     |             |              |


one can use =ielm= REPL using below commands
| commands                     | key | doom keys | custom keys | descriptions |
| +eval/open-repl-other-window |     | spc-o-r   |             |              |
| +eval/open-repl-other-window |     | C-c o r   |             |              |
** Debugging Techniques
*** check if elisp function is defined
ref: http://ergoemacs.org/emacs/elisp_check_defined.html

check function
#+BEGIN_SRC elisp
(fboundp 'info)
#+END_SRC

check variable
#+BEGIN_SRC elisp
(boundp 'auto-mode-alist)
#+END_SRC
*** how to deal with debug issues? see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#inspecting-source-code][here]].
1. error may be displayed in *Message* buffer.
   the *Message*  buffer can be accessed with either.

   | commands                | key   | doom keys | custom keys | descriptions |
   | view-echo-area-messages | c-h-e | spc-h-e   |             |              |
*** how to produce a backtrace? see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85][here]].
| commands        | key | doom keys | custom keys | descriptions |
| doom-debug-mode |     | spc-h-d-d |             |              |
*** if =bin/doom= produces error, see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-bindoom-4][here]].
*** if emacs is frozen, see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-frozen-emacs-5][here]], and [[https://emacs.stackexchange.com/questions/506/debugging-a-frozen-emacs#:~:text=Type%20M%2Dx%20toggle%2Ddebug%2Don,external%20debugger%20such%20as%20gdb%20.][here]].
if =C-g= unfreeze emacs, then you can use buildin debugger by running =toggle-debug-on-quit= and inspect =*Backtrace*= file.

if C-g doesn't help, then the freeze probably happens in the C code, and you'll need to use an external debugger such as gdb. Hit C-h C-d to see the DEBUG file which gives some hints about how to do that. (You can also [[http://git.savannah.gnu.org/cgit/emacs.git/tree/etc/DEBUG][read the DEBUG file in the Emacs repository web interface]].) [[https://emacs.stackexchange.com/questions/14354/how-do-i-debug-an-emacs-crash/14376#14376][This answer]] goes into more details about how to use gdb with Emacs.
*** how to deal with frozen emacs? see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-frozen-emacs-5][here]].
*** profiling, benchmarking, measure and evaluate performance of emacs and elisp code.
- ref
  - see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#profiling-and-benchmarking-5][here]].
  - [[https://emacs.stackexchange.com/questions/539/how-do-i-measure-performance-of-elisp-code][How do I measure performance of elisp code?]]
**** build-in approach
This option is used to inspect what cause emacs to slow down.

=doom/toggle-profiler= must be toggle twice. The first time to start it, and again to prpoduce a report.
| commands             | key | doom keys | custom keys | descriptions |
| doom/toggle-profiler |     | spc-h-T   |             |              |
**** benchmark package (cool stuff)
#+BEGIN_SRC emacs-lisp results: output
;; ref: https://emacs.stackexchange.com/questions/539/how-do-i-measure-performance-of-elisp-code
(require 'benchstat)

;; Decide how much repetitions is needed.
;; This is the same as `benchmark-run-compiled` REPETITIONS argument.
(defconst repetitions 1000000)

;; Collect old code profile.
(benchstat-run :old repetitions (list 1 2))
;; Collect new code profile.
(benchstat-run :new repetitions (cons 1 2))

;; Display the results.
;; Can be run interactively by `M-x benchstat-compare'.
(benchstat-compare)
#+END_SRC

#+RESULTS:


*** search and inspect source code (last resource), see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#inspecting-source-code-9][here]].
**** perform text search on all loaded packages.

| commands                     | key | doom keys | custom keys | descriptions                                              |
| doom/help-search-load-path   |     | spc-h-d-l |             | perform a text search on all pacages in =load-path=       |
| doom/help-search-loaded-file |     | spc-h-d-L |             | perform a text search on all currently loaded =*.el= file |

another option is to jump directly to a file Doom Emacs's source code.
| commands                      | key | doom keys | custom keys | descriptions                                      |
| +default/find-files-in-emacsd |     | spc-f-e   |             | jump to a file in Doom's source (in =~/.emacs.d=) |
| +deafault/browse-emacsd       |     | spc-f-E   |             | browse Doom's source ( in =~/.emacs.d= )          |
*** Command error and how to deal with it, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58][here]].

**** debug =void-function: XYZ=

try to debug with the following code
#+BEGIN_SRC emacs-lisp
;; declare to Emacs where to find XYZ when it is needed:
(autoload 'XYZ "package-name")
;; or do the same with `use-package' instead:
(use-package package-name
  :commands XYZ)
;; or just load it immediately
(require 'package-name)

;; After any of the above you are free to use the function:
(XYZ)
#+END_SRC

**** debug =void-variabe: XYZ=

try to debug with the following code
#+BEGIN_SRC emacs-lisp
;; Setting the variable with setq will create it if it does not exist yet.
;; If it does exist, it will be changed.
(setq XYZ 50)
;; You can use defvar instead, which won't change its existing value, if
;; XYZ is already defined, and also lets you define documentation for it.
(defvar XYZ 50 "Defines how many cacodemons `use-XYZ' should invoke.")
;; Otherwise, load the variable's package eagerly, right before you use
;; it. For example:
(defun use-XYZ ()
  "The function that triggered the error in the backtrace."
  (require 'XYZ-package)
  (do-things-with XYZ))
;; or load it right away so you never have to worry about load order.
(require 'XYZ-package)

;; then you are free to reference the variable however you like. e.g.
(add-to-list 'XYZ 1)
(push 2 XYZ)
(setq XYZ (append XYZ (list 3 4 5)))
#+END_SRC
**** debug =void-commandp: XYZ=

#+BEGIN_QUOTE
XYZ is not a known “command” or does not exist. A command is a function that has been marked as an “interactive” function. If the function exists, this error indicates it hasn’t been marked as interactive, but is being used interactively (most commonly: as a keybind).
#+END_QUOTE

Below is an example of code to reproduce the error.
example 1
#+BEGIN_SRC emacs-lisp
(defun not-a-command ()
 (message "Do stuff"))

(defun is-a-command ()
  (interactive)
  (message "Do stuff"))

(map! "M-x" #'is-a-command)  ; works fine!

(map! "M-x" #'not-a-command) ; throws a commandp: not-a-command error
#+END_SRC

example 2
#+BEGIN_SRC emacs-lisp
(defun not-a-command ()
 (message "Do stuff"))

(defun is-a-command ()
  (interactive)
  (message "Do stuff"))

(global-set-key (kbd "M-x") #'is-a-command)  ; works fine!

(global-set-key (kbd "M-x") #'not-a-command) ; throws a commandp: not-a-command error
#+END_SRC

if function comes from packages. (you didn't write it yourself.), see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#the-function-comes-from-a-package-14][here]].


**** debug =Key sequence ... start with non-prefix key.=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#key-sequence-starts-with-non-prefix-key-15][here]].
**** debug =unable to find theme file for XYZ=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#unable-to-find-theme-file-for-xyz-19][here]].
**** debug =cannot open load file: No such file or directory, ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#cannot-open-load-file-no-such-file-or-directory-23][here]].
**** debug =Error in private config: ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#error-in-private-config-27][here]].
**** debug =end-of-file ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#end-of-file-31][here]].
**** debug other common exceptions.
- =wrong-type-argument X Y=
    a type error; Y is the invalid data that was received and X is the predicate function that would return true if Y were a valid data type. The name of this predicate should clue you in to what data type was expected. e.g. wrong-type-argument
- =number-or-marker-p nil=
   means something expected a number or marker, but got nil instead.
- =wrong-number-of-arguments=
    a function was passed the wrong number of arguments.

*** check for mismatch paren with =check-parens=.
*** avoid outdated byte-compiled elisp files?  see [[https://emacs.stackexchange.com/questions/185/can-i-avoid-outdated-byte-compiled-elisp-files][here]].
set the following
#+BEGIN_SRC emacs-lisp :noeval
(setq load-prefer-newer t)
#+END_SRC
*** force emacs to print backtrace when emacs hangs.
this method should only be used if =toggle-debug-on-quit= doesn't produce backtrace.
*** Checking garbage collection related stuff.
for more quick introduction, read [[https://akrl.sdf.org/][here]].
=gc-elapsed= variable accumulated time elapsed in garbage collections.
~(setq garbage-collection-message t)~ to see log gc process.
=gc-cons-threshold= represents the "Number of bytes of consing between garbage collections."
** Report Bugs
=straight-visit-package-website= quickly open that package's homepage in your browser.
* FAQs
** How/Where to find github (or commit) of the latest emacs package version?
 it is important to note that to find the latest version of emacs packages it is best to search for lastest version from Melpa or Elpa website because it is no garantee that the latest version of github page of the target packages will appear on when search on google.
** Emacs Encryption mechanism.
Emacs uses GnuPG via the =epa= lbirary to automatically encrypt and decrypt andy files that end with =.gpg=.
** How to keep emacsc packages up to date?
- ref
  - [[https://www.youtube.com/watch?v=dtjq68F2dXw&ab_channel=SystemCrafters][Keep your emacs packages up to date - Emacs From Scratch #11]]

1. list packages with =M-x list-packages=
2. Once in =Package Munu= buffer, run =package-menu-mark-upgrades= (default key binding is =U=) to mark all packages to be updated.
** What is relationship of emacs =exec-path= and environment variable =$PATH=
:PROPERTIES:
:ID:       5a83d8b4-d28a-451a-8ec2-b9449828f4ac
:END:
- ref
  - https://emacs.stackexchange.com/questions/550/exec-path-and-path
** shell-mode vs term-mode?
Running a term buffer is much closer to an actual terminal. Here are a few differences:

Shell mode provides very limited terminal emulation. Programs that take advantage of the terminal's full-screen capabilities (e.g. less, mtr, mutt, top) won't work properly. Terminal mode will generally handle these without any problem.
In shell mode, emacs provides tab completion. In terminal mode, the shell or command-line program provide it themselves.
Shell mode buffers the input and sends it to the process on newline. Terminal mode sends the characters to the running process immediately.
Shell mode works like a regular buffer with the usual emacs key bindings. Terminal mode doesn't intercept most control characters unless you explicitly put it into line mode.

* Footnotes
[fn:2] [[https://www.youtube.com/watch?v=tw2-rI2bxSg&ab_channel=SystemCrafters][Emacs Tips - How to Use File and Direectory Local Variables]]

[fn:1] https://youtu.be/2TSKxxYEbII?t=1164
