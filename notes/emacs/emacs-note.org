#+TITLE: Emacs Note

* Map of Contents (MOCs)
** ~+eval/region~ and ~+eval/buffer~ doesn't send results from overlays to ~Message~ buffer, but ~eros-eval-last-sexp~ does.
*** Background (information and description of goal)
- note
  - Why are you doing this? What is the movitation?
  - What is your expectation of the results?

From my brief investigation, I notice that although all commands evaluate lisp code, it wasn't implemented on the same commands. (not much similarity beyond eval and overlays)
* Help sections and realted info
** looking up documentation, see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#looking-up-documentation-3][here]].

| commands                     | key | doom keys | custom keys | descriptions |
| helpful-function -> add-hook |     |           |             |              |
| helpful-variable             |     | spc-h-v   |             |              |
| helpful-key                  |     | spc-h-k   |             |              |
| doom/help-custom-variable    |     | spc-h-V   |             |              |

seaching doom specific documentation

| commands                 | key | doom keys | custom keys | descriptions |
| doom/help-search         |     | spc-h-d-S |             |              |
| doom/help-search-heading |     | spc-h-d-s |             |              |

* Notes for Users
** Built-in Packages and modes
*** Packages
**** Imenu
*****  How does Imenu function works?
~imenu~ function when called when called will jump to a place in the buffer chosen using either a buffer menu or mouse menu.

#+BEGIN_SRC emacs-lisp
(imenu INDEX-ITEM)
#+END_SRC
Jump to a place in the buffer chosen using a buffer menu or mouse menu.
~INDEX-ITEM~ specifies the position.

#+BEGIN_SRC emacs-lisp
(imenu-choose-buffer-index &optional PROMPT ALIST)
#+END_SRC
~imenu-choose-buffer-index~ lets the user select from a buffer index and return the chosen index.

The returned value is of the form (INDEX-NAME . INDEX-POSITION) which is a format of simple elements in ~imenu--index-alist~.

~imenu--index-alist~ is the current buffer index alist.
~imenu--index-alist~ has the following elements:
- simple element
  (INDEX-NAME . POSITION)
- special elements
  (INDEX-NAME POSITION FUNCTION ARGUMENTS...).
- nested sub-alist element
  (INDEX-NAME . SUB-ALIST)

#+BEGIN_SRC emacs-lisp
(imenu-choose-buffer-index)
#+END_SRC

#+RESULTS:
: (Imenu . #<marker at 506 in emacs-note.org>)

#+BEGIN_SRC emacs-lisp
(imenu '((Imenu . #<marker at 506 in emacs-note.org>)))
#+END_SRC

****** [2021-11-07 Sun]: WHAT HAVE I DONE AND WHAT TO DO NEXT?
so the goal is to implement a simple imenu to reproduce the results of different call ~imenu~ on the buffer.

note: behavior of calling ~imenu~ using key binding is different from select ~imenu~ from ~M-x~. Given what I know, I speculate that ~imenu~ take input directly from buffer in which it is, hence, selecting ~imenu~ from ~M-x~ produce undesired side effects.

So far, I unable to pass output from ~imenu-choose-buffer-index~ (which, according to the documentation, suppose to produce INDEX-ITEM ) to ~imenu~, so I suspect that my understanding of ~marker~ concept may blind me from the error.

Next next I planned to read about ~marker~ from [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Markers.html][this page]].
*** Modes
**** edebug mode
- ref
  - tutorial
    - [[https://youtu.be/QRBcm6jFJ3Q?t=416][2015-04-08 Emacs Lisp Development Tips with John Wiegley]]
    - [[https://www.youtube.com/watch?v=odkYXXYOxpo&ab_channel=NicFerrier][Debugging basics]] (This one is more structured and easier to follow)

traditional ways of debugging is to =debug= function, see example below
#+BEGIN_SRC emacs-lisp
(defun foo ()
  (if t
      (progn
        (debug)
        (message "Hello, world"))
    (message "unimplemented")))

(foo)
#+END_SRC



set =toggle-debug-on-error= to t to enable debug on error.

Once in the edebug mode
| commands                   | key | doom keys | custom keys | descriptions |
| debugger-eval-expression   | e   |           |             |              |
| debugger-jump              |     |           |             |              |
| debugger-quit              |     |           |             |              |
| debugger-frame             |     |           |             |              |
| debugger-continue          |     |           |             |              |
| debugger-frame-clear       |     |           |             |              |
| debugger-return-value      |     |           |             |              |
| debugger-step-through      |     |           |             |              |
| debugger-list-functions    |     |           |             |              |
| debugger-eval-expression   |     |           |             |              |
| debugger-record-expression |     |           |             |              |

** Built-in functionality and macros
*** Functionality
**** [[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][Ediff]]
ref:
[[https://www.youtube.com/watch?v=oXsaRENHlXY&ab_channel=oxyscbw][Exploring Emacs: Use/Set up ediff for comparing files for windows]]

Note: It is not intuitive to use at all. Unless, I need to use it, I am better without it.

| commands            | key | doom keys | custom keys | descriptions                    |
| ediff               |     |           |             |                                 |
| ediff3              |     |           |             |                                 |
| ediff-buffer        |     |           |             | compare buffers                 |
| ediff-revision      |     |           |             | 2 git brancehs 1 file           |
| vc-ediff            |     |           |             | look at vc changes from file    |
| ediff-current-file  |     |           |             | unsaved changes (revert-buffer) |
| ediff-documentation |     |           |             | documentation for ediff         |

**** Align
| commands    | key | doom keys | custom keys | descriptions |
| align-regex |     |           |             |              |
*** Emacs components
**** Buffer
***** How =display-buffer= works
- ref
  - [[https://www.youtube.com/watch?v=-H2nU0rsUMY&ab_channel=SystemCrafters][Hey Emacs, Don't Move My Windows! - Customizing display-buffer's behavior]]

When a new buffer is created for display, Emacs uses the =display-buffer= function to figure out where this buffer should be placed on screen.

=display-buffer= consults a series of sources =in order= which contain rules for how windows are selected (or created) to display new buffers:

    1. =display-buffer-overriding-action= - Used by package code to
    temporarily override rules
    2. =display-buffer-alist= - User-defined buffer placement rules (nil by default)
    3. The =action= argument of =display-buffer= - The caller of =display-buffer= can specify its own rules
        #+BEGIN_SRC emacs-lisp
        (display-buffer BUFFER-OR-NAME &optional ACTION FRAME)
        #+END_SRC
    4. =display-buffer-base-action= - User-defined default placememt actions (nil by default)
    5. =display-buffer-fallback-action= - Emacs' default placement rule you see in action every day which the buffer can be displayed. The action function's window (or frame!) in which the buffer will be displayed* Buffers

=display-buffer= builds a list of action functions to try by combining all of these sources and then runs each function in order until one of them returns a window in which the buffer can be displayed. The action function's job is to find (or create) the window (or frame!) in which the buffer will be displayed.

#+BEGIN_SRC emacs-lisp
(display-buffer (get-buffer-create "*doom:scratch*"))
#+END_SRC

#+RESULTS:
: #<window 21 on Test!>

***** What is an action functions?
=signature= of an action function:
#+BEGIN_SRC emacs-lisp
(display-buffer-same-window BUFFER ALIST)
#+END_SRC

=display-buffer= will pass the buffer to be displayed and an association list that the action function can read to look for customizaiton parameters.

**** Marker
*** Completion mechanism
oen of the most important features of the user interface is the way in which the user makes selections from lists of items. for example:

- Opening files
- Switching buffers
- Using M-x to execute commands

There exist package which provide different ways of displaying selections e.g. =ido=, =icomplete=, etc.

More popular adoption is to use =completion framework= like =Helm= or =Ivy= which provide enhanced interfaces and special commands that provide additional behavior.

On the other hand, =Selectr=um and =Vertico= provide you with just completion functionality to build your own =completion framework=.

** Things that effects how emacs behave
*** Process
**** Proper way to call a process
Use the =call-process= function and direct it to a buffer
** Major modes
Order in which emacs looks for major mode.
ref: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html][Choosing File Modes]]
1. file-local variables
   #+BEGIN_SRC md
    ; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-
   #+END_SRC

2. Second, if there is no file variable specifying a major mode, Emacs checks whether the file’s contents begin with ‘#!’.

3. Third, Emacs tries to determine the major mode by looking at the text at the start of the buffer, based on the variable ~magic-mode-alist~.

4. Fourthif Emacs still hasn’t found a suitable major modeit looks at the file’s name. The correspondence between file names and major modes is controlled by the variable ~auto-mode-alist~

5. Finally, if Emacs still hasn’t found a major mode to use, it compares the text at the start of the buffer to the variable ~magic-fallback-mode-alist~
** Navigation
*** org-mode and table

| Commands           | Keys  | description                                                    |
| org-metaleft       | M-h   | Promote heading, list item at point or move table column left. |
| org-metaright      | M-l   | Demote heading, list item at point or move table column right. |
| org-metaup         | M-k   | Move subtree up or move table row up.                          |
| org-metadown       | M-j   | Move subtree down or move table row down.                      |
| org-shiftmetaleft  | M-S-h | Promote subtree or delete table column.                        |
| org-shiftmetaright | M-S-l | Demote subtree or insert table column.                         |
| org-shiftmetaup    | M-S-k | Drag the line at point up                                      |
| org-shiftmetadown  | M-S-j | default-indent-new-line                                        |

*** Windows
**** Key-binding
I figure its best to only list the one I use often.

Note: =prior= key is =pageup=

| command                             | native key | doom key  | custom key | description                |
| delete-window                       | C-x 0      |           | spc-w-0    |                            |
| delete-other-windows                | C-x 1      |           | spc-w-1    |                            |
| evil-window-vsplit                  |            | spc-w-v   |            |                            |
| +evil/window-vsplit-and-follow      |            | spc-w-V   |            |                            |
| shrink-window                       | NA         | NA        |            | shrink vertically          |
| shrink-window-horizontally          | C-x {      |           |            |                            |
| shrink-window-if-larger-than-buffer | C-x -      |           |            |                            |
| enlarge-window                      | C-x ^      |           |            | enlarge vertically         |
| enlarge-window horizontally         | C-x }      |           |            |                            |
| balance-windows                     |            | spc-w-=   |            |                            |
| doom-window-enlarger                |            | spc-w-o   |            |                            |
| window-tear-off                     |            | spc-w-T   |            |                            |
| winner-redo                         |            | spc-w-C-r | spc-w-r    | redo all windows positions |
| winner-undo                         |            | spc-w-C-u | spc-w-u    | undo all windows positions |
| +evil/window-move-up                |            | spc-w-K   |            |                            |
| +evil/window-move-left              |            | spc-w-L   |            |                            |
| +evil/window-move-down              |            | spc-w-J   |            |                            |
| +evil/window-move-right             |            | spc-w-R   |            |                            |
| ace-window                          |            |           |            | jump to window by number   |
| scroll-other-window                 | M-prior    |           |            |                            |
| scroll-other-window-down            | C-M-v      |           |            |                            |
| find-file-other-window              |            |           | spc-w-f    | other file in other window |
** Things related to managing and loading packages
*** =init.el= vs =config.el= vs use-package's =preface= flags [fn:1]
**** =init.el= vs =config.el=
=init.el= is loaded before =require=
=config.el= is loaded after =require=

**** =init.el= vs use-package's =preface= flag

tldr:
=init.el= doesn't raise warning if some code fails to load.
use-package's =preface= flag raise warming if it fails to load.

detail:
=init.el= is intended to be used for things that you don't always need.
#+BEGIN_QUOTE
things in =inite.el= are good to have, but emacs should still work without it.
#+END_QUOTE
Hence, error in =init.el= will not raise backtrace. (it just skip things that don't work. The rest of the code in init.el will still be processed.)
To let use aware that some code are skipped in =init.el=, warning is raised.

When it fails to load things that should have been prepared during =init.el=, no further warning is raised. (beacuse it already raised.) only message that it couldn't be loaded will be shown.

Similar to =init.el=, use-package's =preface= flag are availble during compilation time. Even before =init.el= but it is expected to not fail, so warning will be raised if it failed to load . (since it is used with =use-package= which is used during =config.el=)
** Useful functionality and packages to improve your workflow
*** =macrosteop=
    Expand the macro form following point by one step.

*** Conditions related function
**** =-andfn= return
Return a predicate that returns non-nil if all PREDS do so.

#+BEGIN_SRC emacs-lisp
(funcall (-andfn #'numberp #'cl-evenp) 4)
#+END_SRC

* Notes for Developers
** Customization
*** set keys binding
mapping new key binding to non-defined prefix (by emacs).
#+BEGIN_SRC elisp
(global-set-key (kbd "C-x !") 'enlarge-window-maximize)
#+END_SRC

#+RESULTS:

mapping new key binding to existing prefix (defined by doom emacs)
#+BEGIN_SRC emacs-lisp
(map! :leader "d d" #'dap-debug)
#+END_SRC

** Evaluating elisp
- ref
  - [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#evaluating-elisp-on-the-fly-6][Evaluating elisp on the fly]]

| commands                     | key | doom keys | custom keys | descriptions |
| +eval:region                 |     | g r       |             |              |
| +eval/buffer                 |     | g R       |             |              |
| +eval/buffer-or-region       |     | C-c e     |             |              |


one can use =ielm= REPL using below commands
| commands                     | key | doom keys | custom keys | descriptions |
| +eval/open-repl-other-window |     | spc-o-r   |             |              |
| +eval/open-repl-other-window |     | C-c o r   |             |              |

** Debugging Techniques
*** check if elisp function is defined
ref: http://ergoemacs.org/emacs/elisp_check_defined.html

check function
#+BEGIN_SRC elisp
(fboundp 'info)
#+END_SRC

check variable
#+BEGIN_SRC elisp
(boundp 'auto-mode-alist)
#+END_SRC
*** how to deal with debug issues? see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#inspecting-source-code][here]].
1. error may be displayed in *Message* buffer.
   the *Message*  buffer can be accessed with either.

   | commands                | key   | doom keys | custom keys | descriptions |
   | view-echo-area-messages | c-h-e | spc-h-e   |             |              |
*** how to produce a backtrace? see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85][here]].
| commands        | key | doom keys | custom keys | descriptions |
| doom-debug-mode |     | spc-h-d-d |             |              |
*** if =bin/doom= produces error, see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-bindoom-4][here]].
*** if emacs is frozen, see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-frozen-emacs-5][here]].
*** how to deal with frozen emacs? see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-frozen-emacs-5][here]].
*** profiling and benchmarking, see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#profiling-and-benchmarking-5][here]].
This option is used to inspect what cause emacs to slow down.

=doom/toggle-profiler= must be toggle twice. The first time to start it, and again to prpoduce a report.
| commands             | key | doom keys | custom keys | descriptions |
| doom/toggle-profiler |     | spc-h-T   |             |              |
*** search and inspect source code (last resource), see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#inspecting-source-code-9][here]].
**** perform text search on all loaded packages.

| commands                     | key | doom keys | custom keys | descriptions                                              |
| doom/help-search-load-path   |     | spc-h-d-l |             | perform a text search on all pacages in =load-path=       |
| doom/help-search-loaded-file |     | spc-h-d-L |             | perform a text search on all currently loaded =*.el= file |

another option is to jump directly to a file Doom Emacs's source code.
| commands                      | key | doom keys | custom keys | descriptions                                      |
| +default/find-files-in-emacsd |     | spc-f-e   |             | jump to a file in Doom's source (in =~/.emacs.d=) |
| +deafault/browse-emacsd       |     | spc-f-E   |             | browse Doom's source ( in =~/.emacs.d= )          |
*** Command error and how to deal with it, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58][here]].

**** debug =void-function: XYZ=

try to debug with the following code
#+BEGIN_SRC emacs-lisp
;; declare to Emacs where to find XYZ when it is needed:
(autoload 'XYZ "package-name")
;; or do the same with `use-package' instead:
(use-package package-name
  :commands XYZ)
;; or just load it immediately
(require 'package-name)

;; After any of the above you are free to use the function:
(XYZ)
#+END_SRC

**** debug =void-variabe: XYZ=

try to debug with the following code
#+BEGIN_SRC emacs-lisp
;; Setting the variable with setq will create it if it does not exist yet.
;; If it does exist, it will be changed.
(setq XYZ 50)
;; You can use defvar instead, which won't change its existing value, if
;; XYZ is already defined, and also lets you define documentation for it.
(defvar XYZ 50 "Defines how many cacodemons `use-XYZ' should invoke.")
;; Otherwise, load the variable's package eagerly, right before you use
;; it. For example:
(defun use-XYZ ()
  "The function that triggered the error in the backtrace."
  (require 'XYZ-package)
  (do-things-with XYZ))
;; or load it right away so you never have to worry about load order.
(require 'XYZ-package)

;; then you are free to reference the variable however you like. e.g.
(add-to-list 'XYZ 1)
(push 2 XYZ)
(setq XYZ (append XYZ (list 3 4 5)))
#+END_SRC
**** debug =void-commandp: XYZ=

#+BEGIN_QUOTE
XYZ is not a known “command” or does not exist. A command is a function that has been marked as an “interactive” function. If the function exists, this error indicates it hasn’t been marked as interactive, but is being used interactively (most commonly: as a keybind).
#+END_QUOTE

Below is an example of code to reproduce the error.
example 1
#+BEGIN_SRC emacs-lisp
(defun not-a-command ()
 (message "Do stuff"))

(defun is-a-command ()
  (interactive)
  (message "Do stuff"))

(map! "M-x" #'is-a-command)  ; works fine!

(map! "M-x" #'not-a-command) ; throws a commandp: not-a-command error
#+END_SRC

example 2
#+BEGIN_SRC emacs-lisp
(defun not-a-command ()
 (message "Do stuff"))

(defun is-a-command ()
  (interactive)
  (message "Do stuff"))

(global-set-key (kbd "M-x") #'is-a-command)  ; works fine!

(global-set-key (kbd "M-x") #'not-a-command) ; throws a commandp: not-a-command error
#+END_SRC

if function comes from packages. (you didn't write it yourself.), see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#the-function-comes-from-a-package-14][here]].



**** debug =Key sequence ... start with non-prefix key.=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#key-sequence-starts-with-non-prefix-key-15][here]].
**** debug =unable to find theme file for XYZ=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#unable-to-find-theme-file-for-xyz-19][here]].
**** debug =cannot open load file: No such file or directory, ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#cannot-open-load-file-no-such-file-or-directory-23][here]].
**** debug =Error in private config: ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#error-in-private-config-27][here]].
**** debug =end-of-file ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#end-of-file-31][here]].
**** debug other common exceptions.
- =wrong-type-argument X Y=
    a type error; Y is the invalid data that was received and X is the predicate function that would return true if Y were a valid data type. The name of this predicate should clue you in to what data type was expected. e.g. wrong-type-argument
- =number-or-marker-p nil=
   means something expected a number or marker, but got nil instead.
- =wrong-number-of-arguments=
    a function was passed the wrong number of arguments.

*** check for mismatch paren with =check-parens=.
*** avoid outdated byte-compiled elisp files?  see [[https://emacs.stackexchange.com/questions/185/can-i-avoid-outdated-byte-compiled-elisp-files][here]].
set the following
#+BEGIN_SRC emacs-lisp :noeval
(setq load-prefer-newer t)
#+END_SRC
** Report Bugs
=straight-visit-package-website= quickly open that package's homepage in your browser.
* FAQs
** How/Where to find github (or commit) of the latest emacs package version?
 it is important to note that to find the latest version of emacs packages it is best to search for lastest version from Melpa or Elpa website because it is no garantee that the latest version of github page of the target packages will appear on when search on google.
** Emacs Encryption mechanism.
Emacs uses GnuPG via the =epa= lbirary to automatically encrypt and decrypt andy files that end with =.gpg=.
** How to keep emacsc packages up to date?
- ref
  - [[https://www.youtube.com/watch?v=dtjq68F2dXw&ab_channel=SystemCrafters][Keep your emacs packages up to date - Emacs From Scratch #11]]

1. list packages with =M-x list-packages=
2. Once in =Package Munu= buffer, run =package-menu-mark-upgrades= (default key binding is =U=) to mark all packages to be updated.

* Footnotes

[fn:1] https://youtu.be/2TSKxxYEbII?t=1164
