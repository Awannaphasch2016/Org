#+TITLE: Emacs Note

* Map of Contents (MOCs)
** ~+eval/region~ and ~+eval/buffer~ doesn't send results from overlays to ~Message~ buffer, but ~eros-eval-last-sexp~ does.
*** Background (information and description of goal)
- note
  - Why are you doing this? What is the movitation?
  - What is your expectation of the results?

From my brief investigation, I notice that although all commands evaluate lisp code, it wasn't implemented on the same commands. (not much similarity beyond eval and overlays)
* Terms and Concepts
** struct
example of struct
#+BEGIN_SRC emacs-lisp
;; define struct
(cl-defstruct person name age sex)

;; how struct can be used
(setq dave (make-person :name "Dave" :sex 'male))
(setq other (copy-person dave))
(eq dave other)
(eq (person-name dave) (person-name other))
(person-p dave)
(person-p [1 2 3 4])
(person-p "Bogus")
(person-p '[cl-struct-person counterfeit person object])
#+END_SRC

* Help sections and related info
** looking up documentation, see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#looking-up-documentation-3][here]].

| commands                     | key | doom keys | custom keys | descriptions |
| helpful-function -> add-hook |     |           |             |              |
| helpful-variable             |     | spc-h-v   |             |              |
| helpful-key                  |     | spc-h-k   |             |              |
| doom/help-custom-variable    |     | spc-h-V   |             |              |

seaching doom specific documentation

| commands                 | key | doom keys | custom keys | descriptions |
| doom/help-search         |     | spc-h-d-S |             |              |
| doom/help-search-heading |     | spc-h-d-s |             |              |

* Notes for Users (How to use things?)
** Built-in Packages and modes
*** Packages
**** Imenu
*****  How does Imenu function works?
~imenu~ function when called when called will jump to a place in the buffer chosen using either a buffer menu or mouse menu.

#+BEGIN_SRC emacs-lisp
(imenu INDEX-ITEM)
#+END_SRC
Jump to a place in the buffer chosen using a buffer menu or mouse menu.
~INDEX-ITEM~ specifies the position.

#+BEGIN_SRC emacs-lisp
(imenu-choose-buffer-index &optional PROMPT ALIST)
#+END_SRC
~imenu-choose-buffer-index~ lets the user select from a buffer index and return the chosen index.

The returned value is of the form (INDEX-NAME . INDEX-POSITION) which is a format of simple elements in ~imenu--index-alist~.

~imenu--index-alist~ is the current buffer index alist.
~imenu--index-alist~ has the following elements:
- simple element
  (INDEX-NAME . POSITION)
- special elements
  (INDEX-NAME POSITION FUNCTION ARGUMENTS...).
- nested sub-alist element
  (INDEX-NAME . SUB-ALIST)

#+BEGIN_SRC emacs-lisp
(imenu-choose-buffer-index)
#+END_SRC

#+RESULTS:
: (Imenu . #<marker at 506 in emacs-note.org>)

#+BEGIN_SRC emacs-lisp
(imenu '((Imenu . #<marker at 506 in emacs-note.org>)))
#+END_SRC

****** [2021-11-07 Sun]: WHAT HAVE I DONE AND WHAT TO DO NEXT?
so the goal is to implement a simple imenu to reproduce the results of different call ~imenu~ on the buffer.

note: behavior of calling ~imenu~ using key binding is different from select ~imenu~ from ~M-x~. Given what I know, I speculate that ~imenu~ take input directly from buffer in which it is, hence, selecting ~imenu~ from ~M-x~ produce undesired side effects.

So far, I unable to pass output from ~imenu-choose-buffer-index~ (which, according to the documentation, suppose to produce INDEX-ITEM ) to ~imenu~, so I suspect that my understanding of ~marker~ concept may blind me from the error.

Next next I planned to read about ~marker~ from [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Markers.html][this page]].
**** Semantics Packages
***** References
- emacs documentations
***** Structure of Sematics packages
The following diagram illustrates the strucuture of the =Semantic= package

#+BEGIN_SRC md
                                                             Applications
                                                                 and
                                                              Utilities
                                                                -------
                                                               /       \
               +---------------+    +--------+    +--------+
         C --->| C      PARSER |--->|        |    |        |
               +---------------+    |        |    |        |
               +---------------+    | COMMON |    | COMMON |<--- SPEEDBAR
      Java --->| JAVA   PARSER |--->| PARSE  |    |        |
               +---------------+    | TREE   |    | PARSE  |<--- SEMANTICDB
               +---------------+    | FORMAT |    | API    |
    Scheme --->| SCHEME PARSER |--->|        |    |        |<--- ecb
               +---------------+    |        |    |        |
               +---------------+    |        |    |        |
   Texinfo --->| TEXI.  PARSER |--->|        |    |        |
               +---------------+    |        |    |        |

                    ...                ...           ...         ...

               +---------------+    |        |    |        |
   Lang. Y --->| Y      Parser |--->|        |    |        |<--- app. ?
               +---------------+    |        |    |        |
               +---------------+    |        |    |        |<--- app. ?
   Lang. Z --->| Z      Parser |--->|        |    |        |
               +---------------+    +--------+    +--------+
#+END_SRC

***** Semantic API
Semantic API is provided in all of the major steps in [[*\[\[https://www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-Components.html\]\[Components of Semantics\]\]][Components of Semantics]], best to read it from the documentation, see [[https://www.gnu.org/software/emacs/manual/html_node/semantic/index.html#SEC_Contents][here]].

***** Fundamentals
****** What is usecase of semantic?
Semantic provides a uniform, language-independent API for accessing the parser output. This output can be used by other Emacs Lisp programs to implement “syntax-aware” behavior. Semantic itself includes several such utilities, including user-level Emacs commands for navigating, searching, and completing source code.
******* Application/Modes that build on Semantic API
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Analyzer.html][Analyzer]]
The Semantic Analyzer is a library for performing context analysis on source code. It provides user commands for displaying, completing, and navigating through source code.
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Speedbar.html][Speedbar]]
Speedbar is a program for Emacs which can be used to summarize information related to the current buffer
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/SymRef.html][Symbol Reference (SymRef)]]
Semantic can interface with external symbol reference tools, such as GNU Global and GNU Idutils. These tools provide information about where different tags or symbols appear.
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/MRU-Bookmarks.html][Most Recently Used Bookmarks Mode (MRU Bookmarks Mode)]]
Semantic MRU Bookmarks mode is a minor mode that keeps track of the tags you have edited, allowing you to quickly return to them later (MRU stands for “Most Recently Used”).
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Sticky-Func-Mode.html][Sticky Function Mode]]
Semantic Sticky Function minor mode displays a header line that shows the declaration line of the function or tag on the topmost line in the text area. This allows you to keep that declaration line in view at all times, even if it is scrolls off the “top” of the screen.

In addition, clicking mouse-1 on the header line opens a context menu that contains menu items for copying, killing, or narrowing to that tag.

| commands | key | doom keys | custom keys | descriptions |
| commands                        | key | doom keys | custom keys | descriptions                                                         |
| global-semantic-stickyfunc-mode |     |           |             | Toggle Semantic Sticky Function mode in all Semantic-enabled buffers |

| Variables                          | Description                                                                                            |
| semantic-stickyfunc-sticky-classes | The value of this variable is a list of tag classes that Semantic Sticky Function mode makes “sticky”. |
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Highlight-Func-Mode.html][Highlight Function Mode]]
******** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Tag-Decoration-Mode.html][Tag Decoration Mode]]

****** Why is Semantic invented?
Ordinarily, Emacs uses regular expressions (and syntax tables) to analyze source code for purposes such as syntax highlighting. This approach, though simple and efficient, has its limitations: roughly speaking, it only “guesses” the meaning of each piece of source code in the context of the programming language, instead of rigorously “understanding” it.

****** How does semantic work?
Semantic provides a new infrastructure to analyze source code using parsers instead of regular expressions. It contains two built-in parser generators (an LL generator named Bovine and an LALR generator named Wisent, both written in Emacs Lisp), and parsers for several common programming languages. It can also make use of external parsersprograms such as GNU Global and GNU IDUtils.
****** [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-Components.html][Components of Semantics]]
******* token stream and parser.
step by step of how paring a source code with Semantic works
1. lexical analysis
   1. break it up into its fundamental components
   #+BEGIN_SRC md
        syntax table, keywords list, and options
                         |
                         |
                         v
    input file  ---->  Lexer   ----> token stream
   #+END_SRC
   The output of the lexical analyzer is a list of tokens that make up the file.

   2. The next step is the actual parsing, shown below:
#+BEGIN_SRC md

                    parser tables
                         |
                         v
    token stream --->  Parser  ----> parse tree
#+END_SRC
******* SemanticDB
Cache results of parsing source code files using Semantic Database (SemanticDB)

Parsing large files can take several seconds or more. By default, Semantic automatically caches parse trees by saving them in your .emacs.d directory. When you revisit a previously-parsed file, the parse tree is automatically reloaded from this cache, to save time. See [[https://www.gnu.org/software/emacs/manual/html_node/semantic/SemanticDB.html][SemanticDB]].

By default, SemanticDB is enabled together with Semantic mode. To disable it, remove it from semantic-default-submodes (see [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html][Semantic mode]]). You can also enable or disable SemanticDB with M-x global-semanticdb-minor-mode.

*** Modes
**** edebug mode
- ref
  - tutorial
    - [[https://youtu.be/QRBcm6jFJ3Q?t=416][2015-04-08 Emacs Lisp Development Tips with John Wiegley]]
    - [[https://www.youtube.com/watch?v=odkYXXYOxpo&ab_channel=NicFerrier][Debugging basics]] (This one is more structured and easier to follow)

traditional ways of debugging is to =debug= function, see example below
#+BEGIN_SRC emacs-lisp
(defun foo ()
  (if t
      (progn
        (debug)
        (message "Hello, world"))
    (message "unimplemented")))

(foo)
#+END_SRC

set =toggle-debug-on-error= to t to enable debug on error.

Once in the edebug mode
| commands                   | key | doom keys | custom keys | descriptions |
| debugger-eval-expression   | e   |           |             |              |
| debugger-jump              |     |           |             |              |
| debugger-quit              |     |           |             |              |
| debugger-frame             |     |           |             |              |
| debugger-continue          |     |           |             |              |
| debugger-frame-clear       |     |           |             |              |
| debugger-return-value      |     |           |             |              |
| debugger-step-through      |     |           |             |              |
| debugger-list-functions    |     |           |             |              |
| debugger-eval-expression   |     |           |             |              |
| debugger-record-expression |     |           |             |              |
**** calendar mode
#+BEGIN_SRC emacs-lisp
;; (defun anak/insdate-insert-current-date
;;     )
#+END_SRC
** Built-in functionality and macros
*** Functionality
**** [[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][Ediff]]
ref:
[[https://www.youtube.com/watch?v=oXsaRENHlXY&ab_channel=oxyscbw][Exploring Emacs: Use/Set up ediff for comparing files for windows]]

Note: It is not intuitive to use at all. Unless, I need to use it, I am better without it.

| commands            | key | doom keys | custom keys | descriptions                    |
| ediff               |     |           |             |                                 |
| ediff3              |     |           |             |                                 |
| ediff-buffer        |     |           |             | compare buffers                 |
| ediff-revision      |     |           |             | 2 git brancehs 1 file           |
| vc-ediff            |     |           |             | look at vc changes from file    |
| ediff-current-file  |     |           |             | unsaved changes (revert-buffer) |
| ediff-documentation |     |           |             | documentation for ediff         |

**** Align
| commands    | key | doom keys | custom keys | descriptions |
| align-regex |     |           |             |              |
*** Emacs components
**** Buffer
***** How =display-buffer= works
- ref
  - [[https://www.youtube.com/watch?v=-H2nU0rsUMY&ab_channel=SystemCrafters][Hey Emacs, Don't Move My Windows! - Customizing display-buffer's behavior]]

When a new buffer is created for display, Emacs uses the =display-buffer= function to figure out where this buffer should be placed on screen.

=display-buffer= consults a series of sources =in order= which contain rules for how windows are selected (or created) to display new buffers:

    1. =display-buffer-overriding-action= - Used by package code to
    temporarily override rules
    2. =display-buffer-alist= - User-defined buffer placement rules (nil by default)
    3. The =action= argument of =display-buffer= - The caller of =display-buffer= can specify its own rules
        #+BEGIN_SRC emacs-lisp
        (display-buffer BUFFER-OR-NAME &optional ACTION FRAME)
        #+END_SRC
    4. =display-buffer-base-action= - User-defined default placememt actions (nil by default)
    5. =display-buffer-fallback-action= - Emacs' default placement rule you see in action every day which the buffer can be displayed. The action function's window (or frame!) in which the buffer will be displayed* Buffers

=display-buffer= builds a list of action functions to try by combining all of these sources and then runs each function in order until one of them returns a window in which the buffer can be displayed. The action function's job is to find (or create) the window (or frame!) in which the buffer will be displayed.

#+BEGIN_SRC emacs-lisp
(display-buffer (get-buffer-create "*doom:scratch*"))
#+END_SRC

#+RESULTS:
: #<window 21 on Test!>

***** What is an action functions?
=signature= of an action function:
#+BEGIN_SRC emacs-lisp
(display-buffer-same-window BUFFER ALIST)
#+END_SRC

=display-buffer= will pass the buffer to be displayed and an association list that the action function can read to look for customizaiton parameters.

**** Marker
*** Completion mechanism
oen of the most important features of the user interface is the way in which the user makes selections from lists of items. for example:

- Opening files
- Switching buffers
- Using M-x to execute commands

There exist package which provide different ways of displaying selections e.g. =ido=, =icomplete=, etc.

More popular adoption is to use =completion framework= like =Helm= or =Ivy= which provide enhanced interfaces and special commands that provide additional behavior.

On the other hand, =Selectr=um and =Vertico= provide you with just completion functionality to build your own =completion framework=.
** Things that effects how emacs behave
*** Process
**** Proper way to call a process
Use the =call-process= function and direct it to a buffer
** Major modes
Order in which emacs looks for major mode.
ref: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html][Choosing File Modes]]
1. file-local variables
   #+BEGIN_SRC md
    ; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-
   #+END_SRC

2. Second, if there is no file variable specifying a major mode, Emacs checks whether the file’s contents begin with ‘#!’.

3. Third, Emacs tries to determine the major mode by looking at the text at the start of the buffer, based on the variable ~magic-mode-alist~.

4. Fourthif Emacs still hasn’t found a suitable major modeit looks at the file’s name. The correspondence between file names and major modes is controlled by the variable ~auto-mode-alist~

5. Finally, if Emacs still hasn’t found a major mode to use, it compares the text at the start of the buffer to the variable ~magic-fallback-mode-alist~
** Navigation
*** org-mode and table

| Commands           | Keys  | description                                                    |
| org-metaleft       | M-h   | Promote heading, list item at point or move table column left. |
| org-metaright      | M-l   | Demote heading, list item at point or move table column right. |
| org-metaup         | M-k   | Move subtree up or move table row up.                          |
| org-metadown       | M-j   | Move subtree down or move table row down.                      |
| org-shiftmetaleft  | M-S-h | Promote subtree or delete table column.                        |
| org-shiftmetaright | M-S-l | Demote subtree or insert table column.                         |
| org-shiftmetaup    | M-S-k | Drag the line at point up                                      |
| org-shiftmetadown  | M-S-j | default-indent-new-line                                        |

*** Windows
**** Key-binding
I figure its best to only list the one I use often.

Note: =prior= key is =pageup=

| command                             | native key | doom key  | custom key | description                |
| delete-window                       | C-x 0      |           | spc-w-0    |                            |
| delete-other-windows                | C-x 1      |           | spc-w-1    |                            |
| evil-window-vsplit                  |            | spc-w-v   |            |                            |
| +evil/window-vsplit-and-follow      |            | spc-w-V   |            |                            |
| shrink-window                       | NA         | NA        |            | shrink vertically          |
| shrink-window-horizontally          | C-x {      |           |            |                            |
| shrink-window-if-larger-than-buffer | C-x -      |           |            |                            |
| enlarge-window                      | C-x ^      |           |            | enlarge vertically         |
| enlarge-window horizontally         | C-x }      |           |            |                            |
| balance-windows                     |            | spc-w-=   |            |                            |
| doom-window-enlarger                |            | spc-w-o   |            |                            |
| window-tear-off                     |            | spc-w-T   |            |                            |
| winner-redo                         |            | spc-w-C-r | spc-w-r    | redo all windows positions |
| winner-undo                         |            | spc-w-C-u | spc-w-u    | undo all windows positions |
| +evil/window-move-up                |            | spc-w-K   |            |                            |
| +evil/window-move-left              |            | spc-w-L   |            |                            |
| +evil/window-move-down              |            | spc-w-J   |            |                            |
| +evil/window-move-right             |            | spc-w-R   |            |                            |
| ace-window                          |            |           |            | jump to window by number   |
| scroll-other-window                 | M-prior    |           |            |                            |
| scroll-other-window-down            | C-M-v      |           |            |                            |
| find-file-other-window              |            |           | spc-w-f    | other file in other window |
** Things related to managing and loading packages
*** =init.el= vs =config.el= vs use-package's =preface= flags [fn:1]
**** =init.el= vs =config.el=
=init.el= is loaded before =require=
=config.el= is loaded after =require=

**** =init.el= vs use-package's =preface= flag

tldr:
=init.el= doesn't raise warning if some code fails to load.
use-package's =preface= flag raise warming if it fails to load.

detail:
=init.el= is intended to be used for things that you don't always need.
#+BEGIN_QUOTE
things in =inite.el= are good to have, but emacs should still work without it.
#+END_QUOTE
Hence, error in =init.el= will not raise backtrace. (it just skip things that don't work. The rest of the code in init.el will still be processed.)
To let use aware that some code are skipped in =init.el=, warning is raised.

When it fails to load things that should have been prepared during =init.el=, no further warning is raised. (beacuse it already raised.) only message that it couldn't be loaded will be shown.

Similar to =init.el=, use-package's =preface= flag are availble during compilation time. Even before =init.el= but it is expected to not fail, so warning will be raised if it failed to load . (since it is used with =use-package= which is used during =config.el=)
** Useful functionality and packages to improve your workflow
*** =shell-command=
=shell-command= (=M-x !=)
=shell-command-on-region= (=M-x |=)
**** learn by example
#+BEGIN_SRC emacs-lisp :noeval
;; ref: https://www.masteringemacs.org/article/executing-shell-commands-emacs#:~:text=The%20Basics,*Shell%20Command%20Output*%20buffer.
(defun tidy-html ()
  "Tidies the HTML content in the buffer using `tidy'"
  (interactive)
  (shell-command-on-region
   ;; beginning and end of buffer
   (point-min)
   (point-max)
   ;; command and parameters
   "tidy -i -w 120 -q"
   ;; output buffer
   (current-buffer)
   ;; replace?
   t
   ;; name of the error buffer
   "*Tidy Error Buffer*"
   ;; show error buffer?
   nil))
#+END_SRC

*** =macrosteop=
    Expand the macro form following point by one step.

*** Conditions related function
**** =-andfn= return
Return a predicate that returns non-nil if all PREDS do so.

#+BEGIN_SRC emacs-lisp
(funcall (-andfn #'numberp #'cl-evenp) 4)
#+END_SRC
*** Folding
[[https://stackoverflow.com/questions/27617090/the-scope-of-python-code-folding-in-emacs][The scope of python code folding in emacs]]

* Notes for Developers (How to do and fix things)
** Customization
*** set keys binding
mapping new key binding to non-defined prefix (by emacs).
#+BEGIN_SRC elisp
(global-set-key (kbd "C-x !") 'enlarge-window-maximize)
#+END_SRC

#+RESULTS:

mapping new key binding to existing prefix (defined by doom emacs)
#+BEGIN_SRC emacs-lisp
(map! :leader "d d" #'dap-debug)
#+END_SRC
*** Customize Your IDE environment
- ref
  - [[http://tuhdo.github.io/index.html][Emacs mini manual series]] (Lots of stuff related to functionality that relevant to IDE experience.)
    - [[http://tuhdo.github.io/c-ide.html#sec-9-2][C/C++ Development Environment for Emacs]] (General info on how to customize your own IDE goes beyond C/C++)
** Evaluating elisp
- ref
  - [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#evaluating-elisp-on-the-fly-6][Evaluating elisp on the fly]]

| commands                     | key | doom keys | custom keys | descriptions |
| +eval:region                 |     | g r       |             |              |
| +eval/buffer                 |     | g R       |             |              |
| +eval/buffer-or-region       |     | C-c e     |             |              |


one can use =ielm= REPL using below commands
| commands                     | key | doom keys | custom keys | descriptions |
| +eval/open-repl-other-window |     | spc-o-r   |             |              |
| +eval/open-repl-other-window |     | C-c o r   |             |              |

** Debugging Techniques
*** check if elisp function is defined
ref: http://ergoemacs.org/emacs/elisp_check_defined.html

check function
#+BEGIN_SRC elisp
(fboundp 'info)
#+END_SRC

check variable
#+BEGIN_SRC elisp
(boundp 'auto-mode-alist)
#+END_SRC
*** how to deal with debug issues? see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#inspecting-source-code][here]].
1. error may be displayed in *Message* buffer.
   the *Message*  buffer can be accessed with either.

   | commands                | key   | doom keys | custom keys | descriptions |
   | view-echo-area-messages | c-h-e | spc-h-e   |             |              |
*** how to produce a backtrace? see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85][here]].
| commands        | key | doom keys | custom keys | descriptions |
| doom-debug-mode |     | spc-h-d-d |             |              |
*** if =bin/doom= produces error, see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-bindoom-4][here]].
*** if emacs is frozen, see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-frozen-emacs-5][here]], and [[https://emacs.stackexchange.com/questions/506/debugging-a-frozen-emacs#:~:text=Type%20M%2Dx%20toggle%2Ddebug%2Don,external%20debugger%20such%20as%20gdb%20.][here]].
if =C-g= unfreeze emacs, then you can use buildin debugger by running =toggle-debug-on-quit= and inspect =*Backtrace*= file.

if C-g doesn't help, then the freeze probably happens in the C code, and you'll need to use an external debugger such as gdb. Hit C-h C-d to see the DEBUG file which gives some hints about how to do that. (You can also [[http://git.savannah.gnu.org/cgit/emacs.git/tree/etc/DEBUG][read the DEBUG file in the Emacs repository web interface]].) [[https://emacs.stackexchange.com/questions/14354/how-do-i-debug-an-emacs-crash/14376#14376][This answer]] goes into more details about how to use gdb with Emacs.
*** how to deal with frozen emacs? see [[https://discourse.doomemacs.org/t/what-is-a-backtrace-how-to-produce-them/85#from-frozen-emacs-5][here]].
*** profiling and benchmarking, see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#profiling-and-benchmarking-5][here]].
This option is used to inspect what cause emacs to slow down.

=doom/toggle-profiler= must be toggle twice. The first time to start it, and again to prpoduce a report.
| commands             | key | doom keys | custom keys | descriptions |
| doom/toggle-profiler |     | spc-h-T   |             |              |
*** search and inspect source code (last resource), see [[https://discourse.doomemacs.org/t/how-to-debug-issues/55#inspecting-source-code-9][here]].
**** perform text search on all loaded packages.

| commands                     | key | doom keys | custom keys | descriptions                                              |
| doom/help-search-load-path   |     | spc-h-d-l |             | perform a text search on all pacages in =load-path=       |
| doom/help-search-loaded-file |     | spc-h-d-L |             | perform a text search on all currently loaded =*.el= file |

another option is to jump directly to a file Doom Emacs's source code.
| commands                      | key | doom keys | custom keys | descriptions                                      |
| +default/find-files-in-emacsd |     | spc-f-e   |             | jump to a file in Doom's source (in =~/.emacs.d=) |
| +deafault/browse-emacsd       |     | spc-f-E   |             | browse Doom's source ( in =~/.emacs.d= )          |
*** Command error and how to deal with it, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58][here]].

**** debug =void-function: XYZ=

try to debug with the following code
#+BEGIN_SRC emacs-lisp
;; declare to Emacs where to find XYZ when it is needed:
(autoload 'XYZ "package-name")
;; or do the same with `use-package' instead:
(use-package package-name
  :commands XYZ)
;; or just load it immediately
(require 'package-name)

;; After any of the above you are free to use the function:
(XYZ)
#+END_SRC

**** debug =void-variabe: XYZ=

try to debug with the following code
#+BEGIN_SRC emacs-lisp
;; Setting the variable with setq will create it if it does not exist yet.
;; If it does exist, it will be changed.
(setq XYZ 50)
;; You can use defvar instead, which won't change its existing value, if
;; XYZ is already defined, and also lets you define documentation for it.
(defvar XYZ 50 "Defines how many cacodemons `use-XYZ' should invoke.")
;; Otherwise, load the variable's package eagerly, right before you use
;; it. For example:
(defun use-XYZ ()
  "The function that triggered the error in the backtrace."
  (require 'XYZ-package)
  (do-things-with XYZ))
;; or load it right away so you never have to worry about load order.
(require 'XYZ-package)

;; then you are free to reference the variable however you like. e.g.
(add-to-list 'XYZ 1)
(push 2 XYZ)
(setq XYZ (append XYZ (list 3 4 5)))
#+END_SRC
**** debug =void-commandp: XYZ=

#+BEGIN_QUOTE
XYZ is not a known “command” or does not exist. A command is a function that has been marked as an “interactive” function. If the function exists, this error indicates it hasn’t been marked as interactive, but is being used interactively (most commonly: as a keybind).
#+END_QUOTE

Below is an example of code to reproduce the error.
example 1
#+BEGIN_SRC emacs-lisp
(defun not-a-command ()
 (message "Do stuff"))

(defun is-a-command ()
  (interactive)
  (message "Do stuff"))

(map! "M-x" #'is-a-command)  ; works fine!

(map! "M-x" #'not-a-command) ; throws a commandp: not-a-command error
#+END_SRC

example 2
#+BEGIN_SRC emacs-lisp
(defun not-a-command ()
 (message "Do stuff"))

(defun is-a-command ()
  (interactive)
  (message "Do stuff"))

(global-set-key (kbd "M-x") #'is-a-command)  ; works fine!

(global-set-key (kbd "M-x") #'not-a-command) ; throws a commandp: not-a-command error
#+END_SRC

if function comes from packages. (you didn't write it yourself.), see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#the-function-comes-from-a-package-14][here]].


**** debug =Key sequence ... start with non-prefix key.=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#key-sequence-starts-with-non-prefix-key-15][here]].
**** debug =unable to find theme file for XYZ=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#unable-to-find-theme-file-for-xyz-19][here]].
**** debug =cannot open load file: No such file or directory, ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#cannot-open-load-file-no-such-file-or-directory-23][here]].
**** debug =Error in private config: ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#error-in-private-config-27][here]].
**** debug =end-of-file ...=, see [[https://discourse.doomemacs.org/t/common-errors-how-to-deal-with-them/58#end-of-file-31][here]].
**** debug other common exceptions.
- =wrong-type-argument X Y=
    a type error; Y is the invalid data that was received and X is the predicate function that would return true if Y were a valid data type. The name of this predicate should clue you in to what data type was expected. e.g. wrong-type-argument
- =number-or-marker-p nil=
   means something expected a number or marker, but got nil instead.
- =wrong-number-of-arguments=
    a function was passed the wrong number of arguments.

*** check for mismatch paren with =check-parens=.
*** avoid outdated byte-compiled elisp files?  see [[https://emacs.stackexchange.com/questions/185/can-i-avoid-outdated-byte-compiled-elisp-files][here]].
set the following
#+BEGIN_SRC emacs-lisp :noeval
(setq load-prefer-newer t)
#+END_SRC
*** force emacs to print backtrace when emacs hangs.
this method should only be used if =toggle-debug-on-quit= doesn't produce backtrace.
** Report Bugs
=straight-visit-package-website= quickly open that package's homepage in your browser.
* FAQs
** How/Where to find github (or commit) of the latest emacs package version?
 it is important to note that to find the latest version of emacs packages it is best to search for lastest version from Melpa or Elpa website because it is no garantee that the latest version of github page of the target packages will appear on when search on google.
** Emacs Encryption mechanism.
Emacs uses GnuPG via the =epa= lbirary to automatically encrypt and decrypt andy files that end with =.gpg=.
** How to keep emacsc packages up to date?
- ref
  - [[https://www.youtube.com/watch?v=dtjq68F2dXw&ab_channel=SystemCrafters][Keep your emacs packages up to date - Emacs From Scratch #11]]

1. list packages with =M-x list-packages=
2. Once in =Package Munu= buffer, run =package-menu-mark-upgrades= (default key binding is =U=) to mark all packages to be updated.
** What is relationship of emacs =exec-path= and environment variable =$PATH=
- ref
  - https://emacs.stackexchange.com/questions/550/exec-path-and-path

* Footnotes

[fn:1] https://youtu.be/2TSKxxYEbII?t=1164
