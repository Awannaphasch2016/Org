#+TITLE: Evil Mode
#+filetags: evilmode
#+hugo_base_dir: /home/awannaphasch2016/org/projects/sideprojects/website/my-website/hugo/quickstart

* Blog :blog:
** Emacs Package Explained: How to customize key binding in evil modes?
:PROPERTIES:
:EXPORT_FILE_NAME: Emacs Package Explained: How to customize key binding in evil modes?
:ID:       729ce27d-c7a3-4a1c-98d3-ead527749825
:END:

This is my summary of a more thoroughly explained evil guide, see [[https://github.com/noctuid/evil-guide#why-dont-keys-defined-with-evil-define-key-work-immediately][here]].

*** Keymap Precendence in vanilla emacs

- ~overriding-terminal-local-map~ for terminal-specific key bind
- ~overriding-local-map~
- ~keymap char property at point~ keymaps for the current character. Yasnippet keymaps are in this category.
- ~emulation-mode-map-alists~. Apparently, its more multi-mode keymap management. I am not sure what this means, but if i have to guess it is used in modes that have its known key precedence or other complexity that its key binding system brings. Evil mode keymap falls into this category.
- ~minor-mode-overriding-map-alise~
- ~minor-mode-map-alist~
- ~keymap text property at point~
- ~current-local-map~
- ~current-global-map~

*** Keymap Precendence in =evil mode=
:PROPERTIES:
:ID:       62f8f57a-6b8c-4fed-9e29-25e4dae059e5
:END:
Emacs will look up keymaps in order of top to bottom:
- =evil-make-intercept-map=
- =evil-local-set-key=
- =evil-define-minor-mode-key=
- =evil-define-key= (auxiliary keymaps)
- =evil-make-overriding-map=
- =evil-global-set-map=

*** Evil keymaps states
- =evil-insert-state-map=
- =evil-emacs-state-map=
- =evil-normal-state-map=
- =evil-visual-state-map=
- =evil-motion-state-map=
- =evil-operator-state-map=
- =evil-outer-text-objects-map=
- =evil-inner-text-objects-map=
- =evil-replace-state-map=

Note: there is a non-intuitive behavior of evil motion state which I don't quit understand yet. see [[https://github.com/noctuid/evil-guide#global-keybindings-and-evil-states][here]].
*** Defining evil keymaps

one can define evil keymaps with evil function or native emacs function.

In all of the cases, one needs to provide =key=, =command=, =evil state=, and =keymap=.
#+BEGIN_SRC emacs-lisp
(define-key 'evil-normal-state-map (kbd "a") 'bar) ;; i am not sure why scope of evil keymap  doesn't need to be provided like 'evil-global-set-map' etc.
(evil-define-key 'normal 'global "a" 'bar)
(evil-global-set-key 'normal "a" 'bar)
#+END_SRC

To define lead key, =make-sparse-keymap= can be used as followed.
#+BEGIN_SRC emacs-lisp
(defvar my-leader-map (make-sparse-keymap)
  "keymap for leader key")

;; binding "," to the keymap
(define-key evil-normal-state-map "," my-leader-map)

;; binding ",b"
(define-key my-leader-map "b" 'list-buffers)

;; change the "leader" key to space
(define-key evil-normal-state-map (kbd "-") my-leader-map)
#+END_SRC



*** Why doesn't evil mode work properly?
:PROPERTIES:
:ID:       32f5e348-81cb-4727-bfa8-82b0c06b9dbe
:END:
To be clear, there is no magic underneath. If evil keymaps is in the correct state within correct keymaps precedence, every should work according to keymap search rules.

Recall that evil keymaps are in =emulation-mode-map-alists=, hence, it is possible that other keymaps within the same mode-map can over right it. For example, company mode may override evil mode.
*** Switching Between Evil and Emacs
Note that, here, we don't want to override keybinding. We want to switch between evil and emacs state.

there are the following ways to do this.
- use ~evil-set-initial-state~. Set the initial state when a mode is activated.
- use ~evil-make-override-map~ or ~evil-make-intercept-map~. Reorder key precedence.
- use ~evil-execute-in-emacs-state~. temporary change to emacs state.
- use ~evil-disable-insert-state-bindings~. If this is non-nil, default Emacs bindings are by and large accessible in insert state.

You can also make sure that a keymap is always less than evil keymap using ~evil-make-overiding-map~ and ~evil-make-intercept-map~.

Furthermore, once a key is defined with ~evil-intercept-maps~, it cannot be override. Example of this is ~edebug-mode-map~. To modifier key in intercept-map, you must undefined it. It can be done as followed
#+BEGIN_SRC emacs-lisp
(define-key keymap [intercept-state] nil)
#+END_SRC

On a side note, if you define keybinding with ~setq~, it will have no effect if you define keymap after evil is loaded, so you have to make sure that evil is loaded after as followed.
#+BEGIN_SRC emacs-lisp
(setq evil-overriding-maps nil
      evil-intercept-maps nil)
;; ...
(require 'evil)
#+END_SRC

You can always prevent evil keymaps from ever being overwritten after evil is loaded. You can use ~(advice-add 'evil-make-overriding-map :override #'ignore)~ which can be removed with ~(advice-remove 'evil-make-overriding-map #'ignore)~.

** A Note On X Where X = "adding jump state to command." :note:
:PROPERTIES:
:EXPORT_FILE_NAME: A Note On X Where X = "adding jump state to command."
:ID:       d8985e02-cf07-4348-87a5-dc46f09f75b7
:END:
"Adding jump state to command." implies that position (~(point)~) that the added command is evaluated is added to jump state. In the other word, you can get back to ~(point)~ that you executed the command by using ~(better-jumper-jump-forward)~.

I was trying to add "jump state" to ~(+spell/previous-error)~ and ~+spell/next-error~.

Note that ~+spell~ prefix means this command is provided by a Doom's module. From a quick glance into the code, it is clear that --- just like other Doom's module --- it implements branching condition to allow fallback behavior based on context such as current mode or available packages.

As of <2022-11-22 Tue>, I understand that ~better jumper~ is an Emacs's package whose job is to provide "jumping back and forward functionality". Vanilla Emacs has its own implementation, but, in my opinion, vim's implementation is better -- it is provided by =evil-mode=.

Trying to add "evil's jump state to command" in Doom Emacs is confusing to me because =better-jumper= doesn't provide function that allow command to remember where it "jumped" from -- lets call this behavior "adding jump state to command." Still, I found that I can simulate this behavior by evaluating ref:2258328192.

#+name: 2258328192
#+BEGIN_SRC emacs-lisp :noeval
(progn
  (better-jumper--push)
  (+spell/previous-error))
#+END_SRC


This finding was a deadline. I expected it because it was expecting such obvious usage to be provided by the package itself. I was right. Since I use =evil-mode=, the package that provides this support function is =evil-mode=. This fact was not clear until after I found the solution.

I wasn't familiar with macro and structure in Elisp, so I didn't know what information to focus on when reading code in evil package. By searching for keys words like =jump= and tinkering with functions that have "jump state". I was able to figure out that "jump state" is provided by keyword ~:jump t~. Copied and Pasted code from functions with desired behavior, I added =:jump t= to ~(evil-next-flyspell-error)~, see ref:2519460702. Still, this didn't work. I stuck again.

#+name: 2519460702
#+BEGIN_SRC emacs-lisp :noeval
(evil-define-motion evil-next-flyspell-error (count)
  "Go to the COUNT'th spelling mistake after point."
  :jump t
  (interactive "p")
  (dotimes (_ count)
    (evil--next-flyspell-error t)))
#+END_SRC

Now, since I learned about keywords and have a metal framework of how =evil-mode= works, I was able to find this Reddit's thread titled "[[https://www.reddit.com/r/emacs/comments/cdwmua/evilmode_jump_back_to_last_position/][evil-mode - jump back to last position.]]", and found the correct answer by =RuleAndLine=. He commented that

#+BEGIN_QUOTE
Like others are saying, you want C-o. For commands that don't set a jump by default, you want to add something like this to your init file:

(evil-add-command-properties #'foo :jump t)

Edit: this works for any emacs command, not just the ones defined by evil. So, like, I use (evil-add-command-properties #'org-goto :jump t) so I can go to a random org heading then jump back to where I was before.
#+END_QUOTE

Hence, the correct answer is
#+BEGIN_SRC emacs-lisp :noeval
(evil-add-command-properties #'+spell/next-error :jump t)
(evil-add-command-properties #'+spell/previous-error :jump t)
#+END_SRC

As of <2022-11-22 Tue>, I still don't know how evil use properties to selectively produce behavior based on keyword, but, at this point, this seems like a trivial work, so I omitted it here.


That's it.


Peace.


~milfex-lostex

* Key binding
| commands                    | key | doom keys | custom keys | descriptions                        |
| evil-execute-in-emacs-state |     | \         |             | execute next command in emacs state |
