#+TITLE: Notes
#+hugo_base_dir: /home/awannaphasch2016/org/projects/sideprojects/website/my-website/hugo/quickstart
#+filetags: doom

* Blog :blog:
** Using terminals in Doom Emacs. :terminal:
:PROPERTIES:
:EXPORT_FILE_NAME: Using terminals in Doom Emacs.
:ID:       ca6dd3fd-54f7-4932-baf7-55ccde776f23
:END:

To open multiple terminal, a neat trick is to rename file buffer that terminal is opened [fn:1].

To open file from terminal, one can just =M-x find-file= in the terminal buffer.

*** Footnotes

[fn:1] [[https://stackoverflow.com/questions/2785950/more-than-one-emacs-terminal][stackoverflow: More than one emacs terminal]]
** Keybinding In Doom Emacs :doom:keybinding:
:PROPERTIES:
:EXPORT_FILE_NAME: Keybinding In Doom Emacs
:ID:       66ee45f0-ffe9-40d0-b33d-50b96fb98b50
:END:

Doom Emacs has its own keybinding system. A more accurate explaination is
#+BEGIN_QUOTE
Doom Emacs keybinding system is a wrapper over evil mode such that it is smoothly compatible with Emacs.
#+END_QUOTE

If you use Evil mode without Emacs configuration framework such as Spacemacs or Doom Emacs, it is frustrating to  know if your keybinding is setup properly and whether it will always work as expected in any circumstances. A common point of failure is when your keybinding is overwritten by some packages. Most of the time, creators of those packages don't use evil-mode, so their implementations don't respect evil-mode, rightfully so.

This is annoying because there is no peace of mind. You can't assume that it will always works in all cases. It always a process of "lets try it here, there, what about that, ...". Because of this, if I don't need the binding that BADLY, I don't even try it.

Another annoying point is it is one of those problem that you think it should be fixed long along. Also, its one of those that is not that hard to try to solve, but it isn't interesting enough. On top of that, you also have to expect iterative process of re-implementing things whenever edge cases came up. tedious process of boringness. And because it is solvable, you can't even blame others, but yourself.

Thanks God. Dooms Emacs solves this problem for us. I am not sure how much Doom Emacs fixed this problem. To my knowledge, I have no problem YET using Doom Emacs keybinding configuration system.

Assuming that you use evil-mode and use ~map!~ to modify your key [fn:4], you have to answer the following question.
1. What is the keymap you will use? (=:map=)
2. Do you expect to use your keymap in "evil state" or "emacs state"?
3. Is there any condition you want to be true to enable the key? (=:when=)
4. Which prefix option do you choose, if any? is it =:leader=, =:localleader=, or =:prefix= (your customize prefix).
5. What is the mode you want to enable your keymap? (=:after=)

As an example, I have =org-cdlatex-mode= enable when I open org mode file and =`= (uptick key) is map to ~cdlatex-math-symbol~ command when I am in =evil-insert-state=. I eval the following expression to assign =`= to nil to allow me to type =`= in =evil-insert-state=.
#+BEGIN_SRC emacs-lisp :noeval
(map! :after org-cdlatex-mode
  (:map org-cdlatex-mode-map
    "`" nil))
#+END_SRC

Without =map!=, you will have to write hook to run after =org-cdlatex-mode= is enable as followed.
#+name: rebind_uptick_in_org_cdlatex_mode_map
#+BEGIN_SRC emacs-lisp :noeval
(defun org-cdlatex-mode-map-hook ()
  (define-key org-cdlatex-mode-map (kbd "`") nil))
(eval-after-load 'org-cdltex-mode
  (add-hook ''org-cdllatex-mode-hook 'org-cdlatex-mode-map-hook))
#+END_SRC
As of [2022-07-11 Mon], I am not sure what is the difference usage between ~with-eval-after-load~ vs ~eval-after-load~.

That's it.
Peace.

*** Footnotes
[fn:4] =!= suffix indicate Doom Emacs implementation.

** X Implementation Where X = Doom Emacs's +lookup/ Command. :lookup:doom:
:PROPERTIES:
:EXPORT_FILE_NAME: X Implementation Where X = Doom Emacs's +lookup Command
:ID:       c40d1650-ec6d-44df-83aa-3ce6f424159e
:END:

I was trying to figure out ~+lookup/definition~ that open in other window. In one of the issue, Henrik [fn:2] mention that some =lookup= backend (As an example, =xref= is a built in backend for lookup) are asynchronous and there is no standardized mechanism to talk to them to see whether the command runs successfully [fn:3].

lets call this new command ~+lookup/definition-other-window~
Current possible solutions are
1. ignore validation step to make sure that the command runs succesfully.
2. when the command is called, switch to other window then run ~+lookup/definition~ command.
   It can be implemented as followed
   #+BEGIN_SRC emacs-lisp
(dolist (fn '(definition references))
  (fset (intern (format "+lookup/%s-other-window" fn))
        (lambda (identifier &optional arg)
          "TODO"
          (interactive (list (doom-thing-at-point-or-region)
                             current-prefix-arg))
          (let ((pt (point)))
            (switch-to-buffer-other-window (current-buffer))
            (goto-char pt)
            (funcall (intern (format "+lookup/%s" fn)) identifier arg)))))
   #+END_SRC

I just thinks its interesting, so I figure I write something about it.

That's it.
Peace.

*** Footnotes
:PROPERTIES:
:ID:       8a341485-75ff-4d99-bc38-7aa885a13440
:END:
[fn:2] Henrik is a creator of Doom Emacs.
[fn:3] https://github.com/doomemacs/doomemacs/issues/3397#issuecomment-649124705
** TODO X Implementation Where X = `~/.emacs.d/bin/doom run`
:PROPERTIES:
:ID:       0be5fb6a-6ddc-4b02-b6f1-5040909d902e
:END:

=user-emacs-directory= is =/home/awannaphasch2016/.emacs.d/.local/cache/=
** Implementing X where X = "Custom Doom Emacs's Scratch Buffer" :implementation:scratch:module:
:PROPERTIES:
:EXPORT_FILE_NAME: Implementing X where X = "Custom Doom Emacs's Scratch Buffer"
:END:
I was trying to implement my own scratch buffer.I learned alot about Emacs's way of programming. I gained a new mental debugging tool.

The main function I started to modify is  ~doom/open-scratch-buffer~. The functions deals with opening scratch buffer when current-buffer is inside and outside of a projectile's project.

~doom/open-scratch-buffer~ does the following
- check if scratch will open in the same buffer or as pop up buffer
- Then, it passes arguments to ~(doom-scratch-buffer &optional DONT-RESTORE-P MODE DIRECTORY PROJECT-NAME)~.

~doom-scratch-buffer~ does the following
- create buffer if the name doesn't already exist
- restore existing buffer if buffer already opened by running ~(doom--load-persistent-scratch-buffer project-name)~
- add the scratch buffer to =doom-scratch-buffers=
- add related hooks. then open the buffer.

I ended up copied code from =scratch.el= and modified it. Modification was pretty straight forward. First, I simplified arguments to pass as a way to poke the system to match my prediction of its behavior to its actual behavior.

I learned about how scratch page persist content. Content of doom scratch buffer is saved to =~/.emacs.d/.local/etc/scratch/__default.el= whenever its closed. To persist my scratch buffer content, I created =~/.emacs.d/.local/etc/scratch/__now-n-next.el= to use inplace of =~/.emacs.d/.local/etc/scratch/__default.el=.

After this step, I get the following code.
#+BEGIN_SRC emacs-lisp :noeval
(defun anak/open-scratch-buffer (&optional arg)
  "Pop up a persistent scratch buffer.

If passed the prefix ARG, do not restore the last scratch buffer.
If PROJECT-P is non-nil, open a persistent scratch buffer associated with the
  current project."
  (interactive "P")
  (let (projectile-enable-caching)
    (funcall
     #'pop-to-buffer
     ;; #'switch-to-buffer
     (anak/scratch-buffer
      arg
      'org-mode
      default-directory
      nil))))

(defun anak/scratch-buffer (&optional dont-restore-p mode directory project-name)
  "Return a scratchpad buffer in major MODE."
  (let* ((buffer-name "*anak:now-n-next*")
         (buffer (get-buffer buffer-name)))
    (with-current-buffer
        (or buffer (get-buffer-create buffer-name))
      (setq default-directory directory)
      (setq-local so-long--inhibited t)
      (if dont-restore-p
          (erase-buffer)
        (unless buffer
          (anak/load-persistent-scratch-buffer project-name)
          (when (and (eq major-mode 'fundamental-mode)
                     (functionp mode))
            (funcall mode))))
      (cl-pushnew (current-buffer) doom-scratch-buffers)
      (add-transient-hook! 'doom-switch-buffer-hook (anak/persist-scratch-buffers-h))
      (add-transient-hook! 'doom-switch-window-hook (anak/persist-scratch-buffers-h))
      (add-hook 'kill-buffer-hook #'anak/persist-scratch-buffer-h nil 'local)
      (run-hooks 'doom-scratch-buffer-created-hook)
      (current-buffer))))

(defvar anak/scratch-default-file "__now-n-next"
  "The default file name for a project-less scratch buffer.

Will be saved in `doom-scratch-dir'.")

(defun anak/persist-scratch-buffer-h ()
  "Save the current buffer to `doom-scratch-dir'."
  (let ((content (buffer-substring-no-properties (point-min) (point-max)))
        (point (point))
        (mode major-mode))
    (with-temp-file
        (expand-file-name (concat anak/scratch-default-file
                                  ".el")
                          doom-scratch-dir)
      (prin1 (list content
                   point
                   mode)
             (current-buffer)))))

(defun anak/load-persistent-scratch-buffer (project-name)
  (setq-local doom-scratch-current-project
              (or project-name
                  anak/scratch-default-file))
  (let ((smart-scratch-file
         (expand-file-name (concat doom-scratch-current-project ".el")
                           doom-scratch-dir)))
    (make-directory doom-scratch-dir t)
    (when (file-readable-p smart-scratch-file)
      (message "Reading %s" smart-scratch-file)
      (cl-destructuring-bind (content point mode)
          (with-temp-buffer
            (save-excursion (insert-file-contents smart-scratch-file))
            (read (current-buffer)))
        (erase-buffer)
        (funcall mode)
        (insert content)
        (goto-char point)
        t))))

(defun anak/persist-scratch-buffers-h ()
  "Save all scratch buffers to `doom-scratch-dir'."
  (setq doom-scratch-buffers
        (cl-delete-if-not #'buffer-live-p doom-scratch-buffers))
  (dolist (buffer doom-scratch-buffers)
    (with-current-buffer buffer
      (anak/persist-scratch-buffer-h))))
#+END_SRC

The code wasn't totally correct. When I opened my scratch buffer (=*anak:now-n-next*=), the buffer replaced the current buffer (where my cursor is in). I found that ~pop-to-buffer~ caused this behavior, shown below.
#+BEGIN_SRC emacs-lisp :noeval
...
(funcall
     #'pop-to-buffer
     ;; #'switch-to-buffer
     (anak/scratch-buffer
      arg
      'org-mode
      default-directory
      nil))
...
#+END_SRC


I dig into it further by carefully inspect =*Messages*= output using edebug. I found that ~display-buffer~ applies functions based on file's name. That's it. I changed ~(buffer-name "*anak:now-n-next*")~ to ~(buffer-name "*doom:now-n-next*")~. Now, =*doom:now-n-next*= and =*doom:scratch*= opens buffer the same way.

A Note on ~display-buffer~, ~display-buffer~ collects list of functions to be applied based on class of =display-buffer-*-action= and =*-action= where ~(cdr functions)~ is buffer name.

#+BEGIN_SRC emacs-lisp :noeval
...
(while (and functions (not window))
	  (setq window (funcall (car functions) buffer alist)
	  	functions (cdr functions)))
...
#+END_SRC

Below is a message output by ~display-buffer~'s code section, shown below.

messages are, in order,
1. function name to be applied
2. buffer name
3. list of actions to apply based.

Below is output when ~doom/open-scratch-buffer~ is evalulated.
#+BEGIN_SRC
Result: +popup-buffer

Result: #<buffer *doom:scratch*>

Result: ((actions) (side . bottom) (size . 0.35) (window-width . 40) (window-height . 0.35) (slot) (vslot . -4) (window-parameters (ttl . t) (quit) (select . t) (modeline . t) (autosave . t) (transient . t) (no-other-window . t)))

Result: #<window 115 on *doom:scratch*>
#+END_SRC

Below is output when ~anak/open-scratch-buffer~ is evalulated.
#+BEGIN_SRC
Result: display-buffer-use-some-window

Result: #<buffer *anak:now-n-next*>

Result: nil

Result: #<window 67 on *anak:now-n-next*>
#+END_SRC


That's it.


Peace.


~milfex-lostex

* Doom behavior that could cause error
** skipping recompiling/reloading packing (by using cache), see example of the error here ([[*how to fix error that is caused by running the whole =init.el=.]]).
* Errors
** Errors and Debugging log (logs of how I debug it).
* Installation

Note:
version of emacs in Ubuntu is lower than version of emacs required by Doom emacs, so you must install the required version following this [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#install][guide]]. (Basically, you must new apt-repo with =add-apt-repository ppa:kelleyk/emacs=)

If =$EMACS= environment variable is not set or incorrectly set, you will get =Can't find emacs in your PATH= error.

* Help section and related info
To open doom emacs documentation, use =doom/help.= which is binded to =spc-h-d-h=
* Notes for Users
:PROPERTIES:
:ID:       64cff068-4e80-464f-b9cb-6e577a0ea3f5
:END:
** Keybinding and Commands
:PROPERTIES:
:ID:       fdbcd28e-343c-48c2-ab6a-deefbb20f7d7
:END:
*** scratch pad
:PROPERTIES:
:ID:       d80825f3-dd69-46b6-a378-d95fcacb4fa5
:END:
| commands                              | key | doom keys | custom keys | descriptions |
| doom/switch-to-scratch-buffer         |     | spc-b-X   |             |              |
| doom/switch-to-project-scratch-buffer |     | spc-p-X   |             |              |
| doom/open-scratch-buffer              |     | spc-x     |             |              |
| doom/open-project-scratch-buffer      |     | spc-p-x   |             |              |
| anak/toggle-scratch-buffer            |     |           | spc-"       |              |
*** Search in Doom
:PROPERTIES:
:ID:       aa87b05e-c055-42c1-8b69-54ea01f99f1b
:END:
**** bookmark-based search
| commands         | key | doom keys           | custom keys | descriptions                |
| consult-bookmark |     | spc-s-m  OR spc-ret |             | conduct a book mark search. |

**** .doom.d/.emasc.d search
| commands               | key | doom keys | custom keys | descriptions                                                               |
|                        |     | spc-f-P   |             |                                                                            |
|                        |     | spc-f-p   |             |                                                                            |
|                        |     | spc-f-e   |             |                                                                            |
|                        |     | spc-f-E   |             |                                                                            |
| +default/search-emacsd |     | spc-s-e   |             | conduct a text search recursively in files under the =use-emacs-directory= |
**** project-based search
| commands                | key | doom keys | custom keys | descriptions                                                        |
| project-tile-find-file  |     | spc-spc   |             | conduct a file search recursively under the current project folder. |
| +default/search-project |     | spc-s-p   |             | conduct a text search recursively under the current project root.   |
**** buffer search
:PROPERTIES:
:ID:       d245742b-7abc-4545-9b1e-84c7661fa197
:END:
| commands                                                     | key | doom keys | custom keys | descriptions                                                                            |
| consult-imenu                                                |     | spc-s-i   |             | conduct symbol search on the current buffer                                             |
| +default/search-buffer                                       |     | spc-s-b   |             | conduct text search on the current buffer                                               |
| helm-semantic-or-imenu (consult-imenu built on this command) |     | spc-s-h   |             | Preconfigured helm for semantic or imenu.                                               |
**** directory search
| commands            | key | doom keys | custom keys | descriptions                                                      |
| +default/search-cwd |     | spc-s-d   |             | conduct text search recursively in files under the current folder |
**** org-directory search
| commands                     | key | doom keys | custom keys | descriptions                                  |
| +default/org-notes-search    |     | spc n s   |             | Perform a text search on org-directory.       |
| +default/org-notes-headlines |     | spc n S   |             | Jump to an Org headline in org-agenda-files.  |
| +default/find-in-notes       |     | spc n f   |             | Find a file under org-directory, recursively. |
| +default/browse-notes        |     | spc n F   |             | Browse files from org-directory.              |
**** org agenda search
| commands           | key | doom keys            | custom keys | descriptions                   |
| org-agenda         |     | spc o a a            |             |                                |
| org-tags-view      |     | spc o a m OR spc n m |             | browse tags                    |
| org-todo-list      |     | spc o a t            |             |                                |
| org-search-view    |     | spc o a v            |             |                                |
| consult-org-agenda |     | spc m /              |             | Jump to an Org agenda heading. |
**** citation/bibliograph  search
:PROPERTIES:
:ID:       d3cf80b8-09c8-48ac-80fd-61cc4a5b5900
:END:
| commands         | key | doom keys | custom keys | descriptions |
| org-cite-insert  |     | spc m @   |             |              |
| citar-open-entry |     | spc m b   |             |              |
**** buffer/file-based search
:PROPERTIES:
:ID:       793db9b0-1713-4d50-bd5c-4f127e1776cf
:END:
| commands                      | key | doom keys        | custom keys | descriptions                                      |
| find-file                     |     | spc-. OR spc-f-f |             | conduct file search under the current folder      |
| +default/find-file-under-here |     | spc-f-F          |             | conduct file recursively under the current folder |
| consult-recent-file           |     | spc-f-r          |             | conduct recently opened file search               |
| -                             |     | spc-s-B          |             | search in all open buffer.                        |

*** Files nad Directory Modification
| commands                                      | key | doom keys | custom keys | descriptions                                              |
| doom/move-this-file                           |     | spc-f-R   |             | Move current buffer's file to NEW-PATH.                   |
| +default/yank-buffer-path                     |     | spc-f-y   |             | Copy the current buffer's path to the kill ring.          |
| +default/yank-buffer-path-relative-to-project |     | spc-f-Y   |             | Copy the current buffer's relative path to the kill ring. |
| doom/delete-this-file                         |     | spc-f-D   |             | delete the current file                                   |
*** editing
| commands   | key | doom keys | custom keys | descriptions                |
| embark act |     |           |             | send command to emabark act |
*** ace
| commands   | key | doom keys | custom keys | descriptions |
| ace-window |     | spc-w-a   |             |              |

* Notes for Developers
** Directory and Files Organization (How is doom-emacs connected to emacs?)
From my inspection, I believe that Doom Module enable in =init.el= are located in =~/.emacs.d/modules/tools= which contains ~README~ and configuration code. (the actual code from downloaded packages are still in =~/.emacs.d/.local/straight/repo=)
** debug with sandbox, see [[https://discourse.doomemacs.org/t/testing-elisp-packages-in-dooms-sandbox/74][here]].
** Debugging
*** avoid outdated byte-compiled elisp files?  see [[https://emacs.stackexchange.com/questions/185/can-i-avoid-outdated-byte-compiled-elisp-files][here]].
set the following
#+BEGIN_SRC emacs-lisp :noeval
(setq load-prefer-newer t)
#+END_SRC
*** how to fix error that is caused by running the whole =init.el=.


Example of the error extracted from =~/.emacs.d/.local/doom.error.log=
#+BEGIN_SRC md
(invalid-read-syntax ")")

(read #<buffer  *load*-815022>)

(eval-buffer #<buffer  *load*-815022> nil "/home/awannaphasch2016/.emacs.d/.local/elpa/dap-mode-20211003.934/dap-mode-autoloads.el" nil t)

(load-with-code-conversion "/home/awannaphasch2016/.emacs.d/.local/elpa/dap-mode-20211003.934/dap-mode-autoloads.el" "/home/awannaphasch2016/.emacs.d/.local/elpa/dap-mode-20211003.934/dap-mode-autoloads.el" nil t)

(load "/home/awannaphasch2016/.emacs.d/.local/elpa/dap-mode-20211003.934/dap-mode-autoloads" nil t)

... (more error)
#+END_SRC

From inspecting =eval-buffer= and noticing =(invalid-read-syntax ")")=, I solve the problem by looking in to ="/home/awannaphasch2016/.emacs.d/.local/elpa/dap-mode-20211003.934/dap-mode-autoloads.el"= and found that there indeed mismatch of parenthesis. (using =check-parens=)
Furthermore, the top of =dap-mode-autoloads.el= mentioned that the file is automatically loaded, acknowledge this fact, I suspect that content has been unintentionally edit.

Note: I could have confirmed by doing =git stash=, but it turns out that elpa doesn't use git to clone (This is why =straight.el= was proposed in the first place, see [[file:~/org/notes/emacs/package-manager/straight.org::*Features][here]])

From abit more digging, I realised that doom emacs have the behavior of reloading/recompiling packages to reduce initialization time, but this cause loading and initialization errors.

* FAQ
