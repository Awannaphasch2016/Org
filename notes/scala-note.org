#+TITLE: Scala Note

* Basic and Fundamental
** Nil
Nill is equalent of List()
#+BEGIN_SRC scala
val empty1: List[Int] = List()
// empty: List[Int] = List()

val empty2: List[Int] = Nil
// empty: List[Int] = List()

empty1 == empty2
// res0: Boolean = true
#+END_SRC
** List (aka Linked List)
#+BEGIN_SRC scala
val list1 = List(1,2,3)
// list: List[Int] = List(1, 2, 3)

val list2 = 1 :: 2 :: 3 :: Nil
// list: List[Int] = List(1, 2, 3)

list1 == list2
// res1: Boolean = true

// Nil must bet the last element of the list.
val list = 1 :: 2 :: 3
// <console>:10: error: value :: is not a member of Int
            // val list = 1 :: 2 :: 3
#+END_SRC
** Trait
*** Function1, Function2, ... ,FunctionN
**** it is a function that takes in N input and output something.
** Map
*** Syntax
**** ~val isEven = (i: Int) => i % 2 == 0~
**** ~val sum = (a: Int, b: Int) => a + b~
**** ~val double = (i: Int) => i * 2~
**** ~val triple = (i: Int) => i * 3~
*** How Map is understood by a compiler.
**** ~Map[String, Int]~ (Function1 instance)
***** map string to int
**** ~Map[Int, Int => Int]~ (Function1 instance)
***** map 1 int to a function that takes int and output int.
**** ~Map[(Int, Int) => Int]~  (Function2 instance)
***** map 2 int value to 1 int.
** _ (underscore)
- ref
  - [[https://ananthakumaran.in/2010/03/29/scala-underscore-magic.html#:~:text=Scala%20represents%20anonymous%20functions%20with,underscores%20to%20refer%20different%20parameters.&text=Here%20the%20_%20refers%20to%20the%20parameter][Scala _ [underscore] magic]].
*** models import
#+BEGIN_SRC scala
// imports all the members of the package junit. (equivalent to wildcard import in java using *)
import org.junit._

// imports all the members of junit except Before.
import org.junit.{Before => _, _}

// imports all the members of junit but renames Before to B4.
import org.junit.{Before => B4, _}
#+END_SRC

** Assign an existing function/method to a function variables
#+BEGIN_SRC scala :results output
object fp {
  def double1(i: Int): Int = (i * 2)
  // var double = (i: Int) => i * 2
  val double = double1(_)

  def main(args: Array[String]): Unit = {
    println(double(5))
  }
}
#+END_SRC

#+RESULTS:
: 10
** by-name parameters vs by-value parameters, see example [[file:books/learning-fp-in-scala.org::*Example of by-name parameters use case.][here]].
** currying
[[file:books/learning-fp-in-scala.org::*Chapter 28: Partially-Applied Functions (and Currying)][explaination of what currying and paritially-applied function (PAF) is.]]
*** partially-applied function (PAF)
#+BEGIN_SRC scala :no-eval
def add(x:Int, y:Int) = x + y

// assign regular functions from def to val.
val addFunction = add _

// assign regular functions to curried function
val addCurried = (add _).curried

// now you can used curried function as followed
addCurried(1)(2)

// creating paritially-applied function from the curried function
val addFunctionTwo = addFunction(2)(_)


// now you can used PAF function as followed
addFunctionTwo(5) // 7
#+END_SRC
** grouping methods for scala vector and Seq
| method       | Returns                                                                                                                                               |                                                 |
| groupBy(f)   | A map of collections created by the function f                                                                                                        |                                                 |
| grouped      | Breaks the vector into fixed-size iterable collections                                                                                                |                                                 |
| partition(p) | Two collections created by the predicate p                                                                                                            |                                                 |
| sliding(i,s) | Group elements into fixed size blocks by passing a sliding window of size i and step s over them                                                      |                                                 |
| span(p)      | A collection of two collections; the first created by vector.takeWhile(p)                                                                             | , and the second created by bector.dropWhile(p) |
| splitAt(i)   | A collection of two collections by splitting the vector at index i                                                                                    |                                                 |
| unzip        | The opposite of zip, break a collection into two collections by dividing each element into two pieces; such as breaking up a vector of Tuple2 element |                                                 |

#+BEGIN_SRC scala
val firstTen = (1 to 10).toVector      # Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

firstTen.groupBy(_ > 5)                # Map(false -> Vector(1, 2, 3, 4, 5), true -> Vector(6, 7, 8, 9, 10))
firstTen.grouped(2)                    # Iterator[Vector[Int]] = non-empty iterator
firstTen.grouped(2).toVector           # Vector(Vector(1, 2), Vector(3, 4), Vector(5, 6), Vector(7, 8), Vector(9, 10))
firstTen.grouped(5).toVector           # Vector(Vector(1, 2, 3, 4, 5), Vector(6, 7, 8, 9, 10))

"foo bar baz".partition(_ < 'c')       # (" ba ba", foorz)  // a Tuple2
firstTen.partition(_ > 5)              # (Vector(6, 7, 8, 9, 10), Vector(1, 2, 3, 4, 5))

firstTen.sliding(2)                    # Iterator[Vector[Int]] = non-empty iterator
firstTen.sliding(2).toVector           # Vector(Vector(1, 2), Vector(2, 3), Vector(3, 4), Vector(4, 5), Vector(5, 6), Vector(6, 7), Vector(7, 8), Vector(8, 9), Vector(9, 10))
firstTen.sliding(2,2).toVector         # Vector(Vector(1, 2), Vector(3, 4), Vector(5, 6), Vector(7, 8), Vector(9, 10))
firstTen.sliding(2,3).toVector         # Vector(Vector(1, 2), Vector(4, 5), Vector(7, 8), Vector(10))
firstTen.sliding(2,4).toVector         # Vector(Vector(1, 2), Vector(5, 6), Vector(9, 10))

val x = Vector(15, 10, 5, 8, 20, 12)
x.groupBy(_ > 10)                      # Map(false -> Vector(10, 5, 8), true -> Vector(15, 20, 12))
x.partition(_ > 10)                    # (Vector(15, 20, 12), Vector(10, 5, 8))
x.span(_ < 20)                         # (Vector(15, 10, 5, 8), Vector(20, 12))
x.splitAt(2)                           # (Vector(15, 10), Vector(5, 8, 20, 12))
#+END_SRC
** Type Variance
*** Three possibe relationships between a generic type and the type parameter:
**** Covariance (+A)
***** for all types X and Y, if X is a subtype of Y, then List[X] is a subtype of List[Y]
**** Contravariance (-A)
***** opposite subtype relationship than covariance: if X is a subtype of Y, then List[Y] is a subtype of List[X]. E.g. a class Formatter[-A](m: Mammal) knows how to format a mammal to a String. Then, a Formatter[Dog] object will know how to format a Dog object. It is logical that a Formatter[Mammal] object will know how to format a Dog object, so Formatter[Mammal] is a subtype of Formatter[Dog], but NOT vice-versa. Otherwise, a Formatter[Dog] object could be used to format a sibling Cat object (Mammal subtype), which is incorrect.
**** Invariance (no sign)
***** generic types are invariant by default, i.e. neither covariant, nor contravariant. I.e. if we declare class C[A] and X is a subtype of Y, then C[X] is not a subtype of C[Y], nor is C[Y] a subtype of C[X]. C[X] is unrelated to C[Y].
** Tree
#+BEGIN_SRC scala
// package fpinscala.datastructures

sealed trait Tree[+A]
case class Leaf[A](value: A) extends Tree[A]
case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]

object Tree {

  def size[A](t: Tree[A]): Int = t match {
    case Leaf(_)      => 1
    case Branch(l, r) => 1 + size(l) + size(r)
  }
  def maximum(t: Tree[Int]): Int = t match {
    case Leaf(n)      => n
    case Branch(l, r) => maximum(l) max maximum(r)
  }

  def depth[A](t: Tree[A]): Int = t match {
    case Leaf(_)      => 0
    case Branch(l, r) => 1 + (depth(l) max depth(r))
  }

  def map[A, B](t: Tree[A])(f: A => B): Tree[B] = t match {
    case Leaf(a)      => Leaf(f(a))
    case Branch(l, r) => Branch(map(l)(f), map(r)(f))
  }

  def fold[A, B](t: Tree[A])(f: A => B)(g: (B, B) => B): B = t match {
    case Leaf(a)      => f(a)
    case Branch(l, r) => g(fold(l)(f)(g), fold(r)(f)(g))
  }

  def sizeViaFold[A](t: Tree[A]): Int =
    fold(t)(a => 1)(1 + _ + _)

  def maximumViaFold(t: Tree[Int]): Int =
    fold(t)(a => a)(_ max _)

  def depthViaFold[A](t: Tree[A]): Int =
    fold(t)(a => 0)((d1, d2) => 1 + (d1 max d2))

  def mapViaFold[A, B](t: Tree[A])(f: A => B): Tree[B] =
    fold(t)(a => Leaf(f(a)): Tree[B])(Branch(_, _))
}

object p3 {
  def main(args: Array[String]) = {
    val tree: Tree[Int] =
      Branch(Branch(Leaf(2), Leaf(3)), Branch(Leaf(4), Leaf(5)));

    println(Tree.fold(tree)(_ * 1)(_ * _))
  }
}
#+END_SRC
** Options (Some and None)
#+BEGIN_SRC scala
sealed trait Option[+A]
case class Some[+A](get: A) extends Option[A]
case object None extends Option[Nothing]

object p3 {
  def filterOption[A](as: List[A])(f: A => Boolean): Option[List[A]] =
    if (as == Nil) None
    else {
      val elements = as.filter(f)
      if (elements.isEmpty) None else Some(elements)
    }

  def main(args: Array[String]) = {
    // else Some(as.foldRight(List[A]())((x, xs) => if (f(x)) (x :: xs) else xs))
    val ll = List(5, 3, 2, 4, 5, 1, 4)
    val evensOpt = filterOption(ll)(_ % 2 == 0)
    println("filter even numbers: " + evensOpt) // Some(List(2, 4, 4))
    println(
      "filter empty list: " + filterOption(List[Int]())(_ % 2 == 0)
    ) // None

    // illustrate handling Option values:
    val message = evensOpt match {
      case None      => "no even numbers"
      case Some(lst) => "filtered numbers: " + lst
    }
    println(message)
  }
}
#+END_SRC
#+BEGIN_SRC scala
//hide std library `Option` , since we are writing our own in this chapter
import scala.{Option => _, Some => _, None => _}
trait Option[+A] {
// if defined, return Some(f(x)) or else return None
  def map[B](f: A => B): Option[B] = this match {
    case Some(x) => Some(f(x))
    case _       => None
  }
// if defined, return f(x) or else return None
  def flatMap[B](f: A => Option[B]): Option[B] =
    map(f) getOrElse None
// using pattern matching:
  def flatMap_1[B](f: A => Option[B]): Option[B] = this match {
    case Some(x) => f(x)
    case None    => None
  }
// if defined return embedded value else return by-name argument
  def getOrElse[B >: A](defvalue: => B): B = this match {
    case Some(x) => x
    case None    => defvalue // evaluate and return
  }
// if defined return this option else evaluate and return by-name argument ob:
  def orElse[B >: A](ob: => Option[B]): Option[B] =
    map(Some(_)) getOrElse (ob)
  def orElse_1[B >: A](ob: => Option[B]): Option[B] = this match {
    case Some(x) => this
    case _       => ob
  }
// if Some(x) and f(x) it returns this else None
  def filter(f: A => Boolean): Option[A] = this match {
    case Some(x) if (f(x)) => this
    case _                 => None
  }
// if Some(x) and f(x) it returns this else None
  def filter_1(f: A => Boolean): Option[A] =
    flatMap(x => if (f(x)) this else None)
}

case class Some[+A](get: A) extends Option[A]
case object None extends Option[Nothing]

object p3 {
  def main(args: Array[String]) = {
  }
}
#+END_SRC
** this
*** auxiliary constructor
#+BEGIN_SRC scala
// Scala program to illustrate this keyword
class Addition(i:Int)
{
	// using this keyword
	def this(i:Int, j:Int)
	{
		this(i)
		println(i + " + " + j + " = " + { i + j })
	}
}

// Creating object
object GFG
{
	// Main method
	def main(args:Array[String])
	{
		var add = new Addition(15, 12)
	}
}

#+END_SRC
** getOrElse
#+BEGIN_SRC scala
object p3 {
  def main(args: Array[String]) = {
    // else Some(as.foldRight(List[A]())((x, xs) => if (f(x)) (x :: xs) else xs))
    // val x: Option[Int] = Some(100)
    val x: Option[Int] = None
    println("value for x is :: " + x.getOrElse(0))

    val y: Option[Int] = Some(100)
    println("value for y is :: " + y.getOrElse(0))
  }
}
#+END_SRC
** try catch
#+BEGIN_SRC scala
def safeDiv(x: Int, y: Int): Either[Exception, Int] = {
  try Right(x / y)
  catch { case e: Exception => Left(e) }
}
#+END_SRC
** overload
#+BEGIN_SRC scala
sealed trait Either[+E, +A]
case class Left[+E](value: E) extends Either[E, Nothing]
case class Right[+A](value: A) extends Either[Nothing, A]

object p3 {
  def map2[A, B, C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C] =
    a flatMap (aa => b map (bb => f(aa, bb)))

  def main(args: Array[String]) = {
    def sample_add(x: Int, y: Int): Int = x + y // function we want to test
    // we set up a “test vector” with values 10, 20, 30, where 30 is the expected return value:
    val add_test_result =
      testFunction2("sample_add", 10, 20, 10 + 20)(sample_add)
    // println(add_test_result)
    // a Right value means the test passed: prints Right(sample_add passed)
    // println(sum(2, 1))

    val opt1 = Some(1)
    val opt2 = Some(2)
    val sumBoth = map2(opt1, opt2)(_ + _)
    println(" adding two Some: " + sumBoth)
    println(
      // pass
      " adding " + opt1 + " with a None: " + map2(opt1, None: Option[Int])(
      // failed because None needs to be overloaded with Option[Int] to match argument type
      // " adding " + opt1 + " with a None: " + map2(opt1, None)(
        _ + _
      )
    )
  }
}
#+END_SRC
** For Comprehension
The below expression
~for(x <- c1; y <- c2; z <- c3) yield { expr(x, y, z) }~
compiled to the following expression
~c1.flatMap( x => c2.flatMap( y => c3.map( z => expr(x, y, z) )))~

with a guard condition
~for(x <- c1 if cond ) yield { expr(x) }~
compiled to
~c1.filter( x => cond ).map( x => expr(x))~

With variable
~for(x <- c1; y = expr1(x)) yield { expr2(x, y) }~
compiled to
~c1.map( x => (x, expr1(x)).map{ case (x, y) => expr2(x) }~

*** example
#+BEGIN_SRC scala
var tmp: Option[Int] = for {
    x: Int <- a
    y: Int <- b
} yield x + y
#+END_SRC
#+BEGIN_SRC scala
object p{

  val (n1, n2, n3) = (Some(1), Some(2), Some(3))
  val noneVal: Option[Int] = None
val m = for {
x <- n1
y <- n2
} yield x + y

println(m) // Some (3)
// same as
val m_1 = n1 flatMap (x => n2 map ( y => x + y))
println(m_1) // Some (3)
// what about with 3 bindings:
val m3 = for {
x <- n1
y <- n2
z <- n3
} yield x + y + z
println(m3) // Some (6)
// m3 expression gets compiled to this mess:
val m3_1 = n1 flatMap (x => n2 flatMap ( y => n3 map ( z => x + y + z)))
println(m3_1) // Some (6)
// binding to failure:
val m3_none = for {
x <- n1
y <- noneVal // will "fail" to None
z <- n3
} yield x + y + z
println(m3_none) // None
// using guard:
val m3_even = for {
x <- n1
y <- n2 if y % 2 == 0 // even
z <- n3
} yield x + y + z
println(m3_even) // Some(6)
using guard that will fail:
val m3_odd = for {
x <- n1
y <- n2 if y % 2 != 0 // odd: forces second map (for y) to become None, thus entire
expression fails
z <- n3
} yield x + y + z
println(m3_odd) // None
// with a new binding:
val m3_tuple = for {
x <- n1
y <- n2
z = x - y
} yield (x, y, z)
println(m3_tuple) // Some((1, 2, -1)) , with a tuple inside
}
#+END_SRC

* Scala Specification
** [[file:books/scal-puzzlers.org::*This puzzle make use of "The Scala Language Specification, Section 5.1.1" which produce adapting argument lists behavior.][This puzzle make use of "The Scala Language Specification, Section 5.1.1" which produce adapting argument lists behavior.]]
* Scala Compiler
** Eta Expansion (expand scala method to function.)
** Scala Compiler Commandlines
***  The Scala compiler's -Xlint option enables recommended additional warnings that you can use to flag suspicious language usage.
* Examples
** implement sum with recursion
#+BEGIN_SRC scala
object ob{
  def sum(list: List[Int]): Int = list match {
    case Nil => 0
    case head:: tail => head + sum(tail)
  }

  def main(args: Array[String]) = {
    println(sum(List(1,2,3,4)))
  }
}
#+END_SRC
* Debugging
** getting stack trace of compiled programs after program finish running, see [[file:books/learning-fp-in-scala.org::*Manually dumping the stack with the sum examples][here]].
* Help
** scala standard library, see [[https://www.scala-lang.org/api/current/][here]].

* FAQs
** functions vs methods
** how to create scala projects with sbt?
note: scala/scala-seed.g8 is a template

create new scala project in the current directory.
#+BEGIN_SRC sh
sbt new scala/scala-seed.g8
#+END_SRC
